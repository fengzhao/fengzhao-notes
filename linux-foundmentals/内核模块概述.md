# 概述

理解操作系统工作原理最好的方法是抽象思维，换句话说，你可以暂时忽略大部分细节。

就像坐车一样，通常你不会去在意车内固定发动机的装配螺栓，也不会关心你走的路是谁修筑的。

如果你是一个乘客的话，你可能只关心车要做的事情（比如车要把你带到哪）以及车的一些基本操作（比如如何打开车门、怎样系好安全带）。

如果你在开车的话，就需要了解更多的细节，比如如何控制油门、怎样换挡，还有如何处理意外情况。

如果我们觉得开车这个事情太复杂，就可以运用“抽象思维”来帮助理解。首先你可以将“一辆汽车在路上行驶”抽象为三个部分：汽车、道路和驾驶操作。

这样有助于将复杂的问题分解开来。如果道路颠簸，你不会去埋怨车辆本身和你的驾驶技术。

相反，你可能会问为什么这条路这么烂，或者如果这是条新修的路的话，那么筑路工人的活干得可真够差劲的。

软件开发人员运用抽象思维来开发操作系统和应用程序。在计算机软件领域有许多术语来描述抽象的子系统，如子系统、模块和包等。本书中我们使用组件这个相对简单的词。在软件开发过程中，开发人员通常不用太关心他们需要使用的组件的内部结构，他们只关心能使用哪些组件，以及怎么个用法。





一些老旧的资料建议给 `/boot` 专门分一个 100MB 的分区。

曾经给 `/boot` 一个很小的分区是有十分充足的理由的，因为在二十几年前（甚至更久了），BIOS 只能认一个 1024 柱面的硬盘，如果启动文件放在 0-1023（从 0 开始数，共 1024 个柱面）之外，BIOS 就无法读取启动所需的文件，从而无法启动。为了兼容这种 BIOS，就需要在磁盘前端分出一个小分区专门来存储启动文件。





# 引导装载程序

在启动过程的最开始，引导装载程序启动内核，然后内核和init启动。引导装载程序的工作看似很简单：将内核加载到内存，然后使用一系列内核参数启动内核。



Linux引导装载程序的核心功能如下：

- 从多个内核中选择一个使用；
- 从多个内核参数集中选择一个使用；
- 允许用户手动更改内核映像名和参数（例如使用单用户模式）；
- 支持其他操作系统的启动。



自Linux内核问世以来，引导装载程序的功能得到了极大的增强，加入了历史记录和菜单界面，不过最基本的需求仍然是能够灵活选择内核映像和参数。



在个人电脑上，引导装载程序使用基本输入输出系统（以下简称 BIOS）或者统一可扩展固件接口（Unified Extensible Firmware Interface，以下简称UEFI）

几乎所有的磁盘设备都有固件系统供BIOS通过线性块寻址（Linear Block Addressing）访问硬件。虽然性能不怎么样，但是这种方式可以访问磁盘的任意位置。

引导装载程序往往是唯 一使用BIOS访问磁盘的程序。内核使用的是它自己的高性能驱动程序。

大多数现在的引导装载程序都能够读取分区表，内建以只读模式访问文件系统的功能，因此 它们能够查找和读取文件。这使得动态配置和完善引导装载程序变得非常简单。

并不是所有的 Linux引导装载程序都有这些功能，配置引导装载程序因而变得困难得多。

GRUB意指大一统引导装载程序（Grand Unified Boot Loader）。 GRUB有一个较老的版本叫作GRUB Legacy，现在逐渐被淘汰了。

Centos 7 默认使用`GRUB2`引导系统启动，`GRUB2` 是基于 `GRUB` 开发成更加安全强大的多系统引导程序，最新`Linux`发行版都是使用`GRUB2`作为引导程序。

同时`GRUB2`采用了模块化设计，使得`GRUB2`核心更加精炼，使用更加灵活，同时也就不需要像GRUB分为 stage 1、stage 1.5、stage 2三个阶段。







# 内核概述



Linux内核最早是于1991年由芬兰黑客林纳斯·托瓦兹为自己的个人电脑开发的，他当时在Usenet新闻组comp.os.minix登载帖子，这份著名的帖子标志着Linux内核计划的正式开始。

如今，该计划已经拓展到支持大量的计算机体系架构，远超其他操作系统和内核。

它迅速吸引了一批开发者和用户，利用它作为其他自由软件项目的内核，如著名的 GNU 操作系统。

而今天，Linux 内核已接受了超过1200家公司的近12000名程序员的贡献，其中包括一些知名的软硬件发行商。

从技术上说，Linux 只是一个符合POSIX 标准的内核。

它提供了一套应用程序接口（API），通过接口用户程序能与内核及硬件交互。仅仅一个内核并不是一套完整的操作系统。

有一套基于 Linux 内核的完整操作系统叫作Linux 操作系统，或是`GNU/Linux`（在该系统中包含了很多GNU 计划的系统组件）。



**POSIX标准**

早期的Unix可谓是“狂野的西部”。各个公司都在不断推陈出新，将操作系统引往不同的发展方向。

POSIX：可移植操作系统接口（Portable Operating System Interface of UNIX，缩写为 POSIX ）

发布者为电气与电子工程师协会（Institute of Electrical and Electronics Engineers），简称IEEE。

POSIX是IEEE为要在各种UNIX操作系统上运行的软件而定义的一系列API标准的总称，其正式称呼为IEEE 1003，而国际标准名称为ISO/IEC 9945。

POSIX.1 已经被国际标准化组织（International Standards Organization，ISO）所接受，被命名为 ISO/IEC 9945-1:1990 标准。

https://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html



**操作系统**

广义上的操作系统，就是整个计算机硬件上层的所有软件，可以分为两部分：操作系统的



rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。

在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。

 所以说，rootfs 只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。那么，对于容器来说，这个操作系统的“灵魂”又在哪里呢？



**操作系统的核心——内核**

内核就是狭义上的操作系统，主要是用来管理和分配计算机资源（CPU，RAM，和其他设备）。

对于Linux系统，**一般会将内核的可执行文件命名为 /boot/vmlinuz-4.15.0-52-generic 类似的路径，后面的数字表示内核版本号。**

内核及其参数（通常是）在root文件系统中。因为内核此时还没有开始运行，无法遍历文件系统，所以内核参数需要被放到一个容易存取的地方。

并且此时用于访问磁盘的内核设备驱动还没有准备好，这听起来有点像“鸡生蛋，蛋生鸡”。





GRUB最重要的一个功能是对内核映像和配置的选择更为简便。我们可以通过查看菜单来了 解GRUB。GRUB界面易于操作，不过Linux的发行版尽可能将引导装载程序隐藏起来，你可能没 机会看到。

在开机时，BIOS或者固件启动屏幕出现时按住SHIFT来打开GRUB菜单。按E键查看引导装载程序命令的默认启动选项。

root文件系统被设置为一个UUID，内核映像是/boot/vmlinuz-5.4.0-28-generic ，内核参数包括 ro 、 quiet 和 splash 。初始RAM文件系统是 /boot/initrd.img-3.2.0- 31-generic-pae 。

(1) BIOS或者固件初始化硬件，在启动存储设备上寻找启动代码。

(2) BIOS和固件运行找到的启动代码，开始GRUB。

(3) 加载GRUB核心。

(4) 初始化GRUB核心，此时GRUB可以读取磁盘和文件系统。

(5) GRUB识别启动分区，在那里加载配置信息。

(6) GRUB为用户提供一个更改配置的机会。

(7) 超时或者用户完成操作以后，GRUB执行配置（执行顺序在5.5.2节有介绍）。

(8) 执行过程当中，GRUB可能会在启动分区中加载额外的代码（模块）。

(9) GRUB执行 boot 命令，以加载和执行配置信息中 linux 命令指定的内核。

GRUB有自己的设备寻址方式。例如，系统检测到的第一个硬盘是hd0，然后 是hd1，以此类推。然而设备分配会有变化。还好GRUB能够在所有的分区中通过UUID来查找得 内核所在的分区。

​                root@racknerd-79c7a3:~# cat /proc/cmdline BOOT_IMAGE=/boot/vmlinuz-5.4.0-28-generic root=UUID=9de45e18-29e7-4330-b5ab-8a272f87aa36 ro net.ifnames=0 biosdevname=0 netcfg/do_not_use_netplan=true root@racknerd-79c7a3:~#               

这些参数有的是一个单词的长度，诸如 ro 、 quiet ，有的是 key=value 这样的配对（例如 vt.handoff=7 ）。

Linux 内核版本命名在不同的时期有其不同的规范，我们熟悉的也许是 2.x 版本奇数表示开发版、偶数表示稳定版，但到 2.6.x 以及 3.x 甚至将来的 4.x ，内核版本命名都不遵守这样的约定。

在 Linux 内核官网上你会看到主要有四种类型的内核版本

- **mainline** 是主线版本，目前主线版本为 6.2
- **stable** 是稳定版，由 mainline 在时机成熟时发布，稳定版也会在相应版本号的主线上提供 bug 修复和安全补丁，但内核社区人力有限，因此较老版本会停止维护，而标记为 **EOL** (End of Life)的版本表示不再支持的版本。
- **longterm** 是长期支持版，目前还处在长期支持版的有五个版本的内核，分别为 3.10、3.4、3.2、2.6.34、2.6.32，长期支持版的内核等到不再支持时，也会标记**EOL**。



# 内核模块概述

> 内核模块是一段可以动态加载进内核的代码

Linux 内核模块的确切定义是，能够根据需要在内核中动态加载和卸载的代码段。这些模块可以增强内核功能，而无需重启系统。





**设备驱动模块**就是一个明显的例子，它有助于内核与连接到系统的硬件组件进行交互。

在没有模块的情况下，主流方法倾向于单片内核，要求将新功能直接集成到内核映像中。这种方法会导致内核变大，当需要新功能时，就必须重建内核并随后重启系统。





我们常见的文件系统、驱动程序等都可以通过模块的方式添加到内核而无需对内核重新编译，这在很大程度上减少了操作的复杂度。模块机制使内核预编译时不必包含很多无关功能，把内核做到最精简，后期可以根据需要进行添加。而针对驱动程序，因为涉及到具体的硬件，很难使通用的，且其中可能包含了各个厂商的私密接口，厂商几乎不会允许开发者把源代码公开，这就和linux的许可相悖，模块机制很好的解决了这个冲突，允许驱动程序后期进行添加而不合并到内核。



Linux 发行版在软件包中提供了 `modprobe `、 `insmod `和 `depmod `命令。

```bash
# Ubuntu/Debian GNU/Linux
$ sudo apt-get install build-essential kmod
```

要了解当前内核中已经加载了哪些模块，请使用 `lsmod `命令。

```
lsmod
```





模块存储在 /proc/modules 文件中，因此也可以用以下命令查看它们：







在深入研究代码之前，需要注意一些事项。每个人的系统都存在差异，个人的方法也各不相同。要成功编译和加载 "hello world "程序，有时可能会遇到困难。

令人欣慰的是，第一次尝试就克服了最初的障碍，为以后的工作顺利进行铺平了道路。