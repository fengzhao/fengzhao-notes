# 开放容器计划



**开放容器计划 (OCI)** 是一个轻量级、开放的治理结构（项目），在 Linux 基金会的支持下，由于 2015 年 6 月 22 日由 Docker、CoreOS 和其他容器行业的领导者推出成立。

旨在围绕容器格式和运行时创建开放的行业标准。

OCI标准规范的诞生，抛开它成立的商业目的不提，OCI本身存在的意义在于为社区提供一套围绕着容器镜像规范和runtime规范的工业级标准。

目前 OCI 主要有三个规范：**运行时规范** [runtime-spec](https://github.com/opencontainers/runtime-spec) ，**镜像规范** [image-spec](https://www.github.com/opencontainers/image-spec) 以及不常见的**镜像仓库规范** [distribution-spec](https://github.com/opencontainers/distribution-spec) 。

其实 OCI 规范就是一堆 markdown 文件啦，内容也很容易理解，不像 RFC 和 ISO 那么高深莫测，所以如果想对容器镜像有个深入的了解还是推荐大家去读一下这些 markdown 文件😂。



## 镜像规范



OCI镜像规范定义了如何去创建OCI镜像，源文件规范内容如下：

```
├── annotations.md         # 注解规范
├── config.md              # image config 文件规范
├── considerations.md      # 注意事项
├── conversion.md          # 转换为 OCI 运行时
├── descriptor.md          # OCI Content Descriptors 内容描述
├── image-index.md         # manifest list 文件
├── image-layout.md        # 镜像的布局
├── implementations.md     # 使用 OCI 规范的项目
├── layer.md               # 镜像层 layer 规范
├── manifest.md            # manifest 规范
├── media-types.md         # 文件类型
├── README.md              # README 文档
├── spec.md                # OCI 镜像规范的概览
```





### 注解规范



使用规则

- Annotations必须是键值对，其中键必须是string类型的。
- 键必须唯一，最佳实践是使用命名空间，将其做区分。
- 值必须存在，但是可以是空字符串。
- org.opencontainers前缀的键是OCI规范的，不要随便用。
- org.opencontainers.image前缀的键是OCI镜像规范的，不要随便用。
- 使用镜像时，不要因为遇到了未知的注解，而直接抛出错误。
- 预定义的一些注解
  - org.opencontainers.image.created 镜像构建的日期 (string, RFC 3339)。
  - org.opencontainers.image.authors 镜像的负责人或组织 (string)
  - org.opencontainers.image.homepage 镜像相关信息地址 (string, URL)
  - org.opencontainers.image.documentation 镜像帮助文档地址 (string, URL)
  - org.opencontainers.image.source 镜像源代码地址 (string, URL)
  - org.opencontainers.image.ref.name 镜像名称（Tag） (string) 



其他需要考虑的问题
  可扩展性
    为了保证可扩展性。使用该规范的实现，不能因为获取到了一些规范之外的属性，而产生错误或者是异常。

规范化
OCI 镜像是基于内容寻址的。
内容寻址的一大好处就是可以共享重复的数据。
多个镜像依赖同一个层时，这个层只会存储一份。
使用不同的序列化算法时，语义上一样的层往往会得到不用的Hash值，这样的话这样语义上一样的层就会被存储两份。这两份是一样的。
为了保证高效存储，我们必须使用权威的序列化方式。
这样的话多个不同的该规范实现在推送时表现出来的行为将会是一致的。
许多组件都是JSON格式的，这里也应该使用权威的序列化方式。







比如，我们编写 dockerfile 时，就可以遵循注解规范，

```dockerfile
FROM funnyzak/alpine-cron

ARG BUILD_DATE
ARG VCS_REF

LABEL org.label-schema.vendor="funnyzak<silenceace@gmail.com>" \
    org.label-schema.name="mysql backup and notify" \
    org.label-schema.build-date="${BUILD_DATE}" \
    org.label-schema.description="This image is based on Alpine Linux image, which is only a 28MB image." \
    org.label-schema.docker.cmd="docker run --name=backdb -d --restart=always  -e 'DB_HOST=db-container'  -e 'DB_PORT=3306'  -e 'DB_USER=potato'  -e 'DB_PASSWORD=123456'  -e 'DB_NAMES=wordpress_db ghost_db'  -e 'DUMP_FILE_EXPIRE_DAY=30'  -e 'DB_DUMP_CRON=0 0 * * *'  -v '/local/path/db:/db'  funnyzak/mysql-backup" \
    org.label-schema.url="https://yycc.me" \
    org.label-schema.version="1.0.0" \
    org.label-schema.schema-version="1.0"	\
    org.label-schema.vcs-type="Git" \
    org.label-schema.vcs-ref="${VCS_REF}" \
    org.label-schema.vcs-url="https://github.com/funnyzak/mysql-backup-docker" 
```

