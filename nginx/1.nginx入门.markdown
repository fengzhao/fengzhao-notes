# Nginx 介绍



Nginx ("engine x") 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。

Nginx 是由 Igor Sysoev 为俄罗斯著名的 Rambler.ru 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。

其将源代码以类 BSD 许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。

由于 Nginx 使用基于事件驱动的架构，能够并发处理百万级别的 TCP 连接，高度模块化的设计和自由的许可证使得扩展 Nginx 功能的第三方模块层出不穷。

因此其作为 Web 服务器被广泛应用到大流量的网站上，包括淘宝、腾讯、新浪、京东等访问量巨大的网站。

2015 年 6 月，Netcraft 收到的调查网站有 8 亿多家，主流 web 服务器市场份额（前四名）如下表：

| Web服务器         | 市场占有率 |
| :---------------- | :--------: |
| Apache            |   49.53%   |
| Nginx             |   13.52%   |
| Microsoft IIS     |   12.32%   |
| Google Web Server |   7.72%    |

其中在访问量最多的一万个网站中，Nginx 的占有率已超过 Apache。



Nginx 是一个高性能的 Web 服务器，从 2001 年发展至今，由于 Nginx 对硬件和操作系统内核特性的深度挖掘，使得在保持高并发的同时还能够保持高吞吐量。

Nginx 还采用了模块设计，有大量的第三方模块可以扩展 Nginx 的功能，因此 Nginx 的场景非常丰富，同时 Nginx 采用的是 BSD 许可证，赋予了 Nginx 最大的灵活性。

简单来说，Nginx 具有以下几个优点：


- 速度快
- 高并发，高性能
- 可扩展性好
- 高可靠，一年之中停机时间可能只有几秒
- 热部署，可以不重启升级
- 灵活性高，采用BSD 许可证



> BSD开源协议是一个给予使用者者很大自由的协议。
>
> 基本上使用者可以“为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。



截止 2019 年 9 月份，Nginx 的市场份额已经达到了 33%，且还在持续增长，稳居市场头把交椅。



## 诞生背景

Nginx 出现的背景是由于互联网的快速普及导致数据量的快速增长，同时催生出了海量的连接。

传统的 Apache 等服务器采用的是单进程模型，这意味着，每处理一个请求就会创建一个进程，这不但存在进程创建的开销。

而且进程之间相互切换产生的上下文开销也非常耗费 CPU 资源，导致这种传统的服务器在面对成千上万的并发连接时，性能非常低下，而这是快速发展的互联网所不能够忍受的。

在这种背景下，Nginx 采用的是进程池和 epoll 处理模型，这二者加起来使得 Nginx 的性能非常优异，一台 32 核的机器上可以支撑数千万的并发连接。

Nginx 有一个 master 进程和若干个 worker 进程。

master 进程是用来管理 worker 进程的，worker 进程负责处理具体的请求，worker 进程是 master 进程的子进程。

Nginx服务器的一个显著优势是能够同时处理大量并发请求。它结合多进程机制和异步机制对外提供服务，异步机制使用的是异步非阻塞方式

Nginx服务器启动后，可以产生一个主进程（master process）和多个工作进程（worker processes），其中可以在配置文件中指定产生的工作进程数量。

Nginx服务器的所有工作进程都用于接收和处理客户端的请求。这类似于Apache使用的改进的多进程机制，预先生成多个工作进程，等待处理客户端请求。

每个工作进程使用了异步非阻塞方式，可以处理多个客户端请。当某个工作进程接收到客户端的请求以后，调用IO进行处理，如果不能立即得到结果，就去处理其他的请求；

而客户端在此期间业务需等待响应，可以去处理其他的事情；当IO调用返回结果时，就会通知此工作进程；该进程的到通知，暂时挂起当前处理的事务，去响应客户端请求。

客户端请求数量增长、网络负载繁重时，Nginx服务器使用多进程机制能够保证不增长对系统资源的压力；同时使用异步非阻塞方式减少了工作进程在I/O调用上的阻塞延迟，保证了不降低对请求的处理能力。



## Nginx 及其周边

介绍完 Nginx 的背景，我们就该说说 Nginx 周边了。目前基于 Nginx 二次开发的软件主要如下：

- 官方 Nginx。包含开源版（nginx.org）和商业版（nginx.com）
- [Tengine](https://tengine.taobao.org/)，Tengine 是由淘宝网发起的 Web 服务器项目，目前已经开源。
- [OpenResty](https://openresty.org/cn/)，OpenResty 通过 Lua 对 Nginx 进行扩展，使得扩展 Nginx 模块变得异常轻松
- [kong](https://github.com/Kong/kong)，Kong Gateway (OSS) ，Kong是一个云原生，快速，可扩展和分布式微服务的开源API网关。
- [apisix](https://apisix.apache.org/zh/)，Apache APISIX 是一个动态、实时、高性能的云原生 API 网关，提供了负载均衡、动态上游、灰度发布、服务熔断、身份认证等功能。



针对我们日常工作学习来说，选择官方开源版的 Nginx 或者 OpenResty 就可以了。

### Nginx 版本策略

------

在 Nginx 的[开源代码库](http://hg.nginx.org/nginx/branches)中，有两种分支，分别是 mainline 和 stable。

-  Mainline 相当于开发分支，更新比较活跃，包含引入一些新的功能或者bug修复，版本号的第二个数字如果是奇数，那就是 Mainline 版本，比如 1.17.0。
- Stable 分支很容易理解，就是相对稳定的版本，除非有重大Bug，否则在它的生命周期内不会更新，版本号的第二个数字如果是偶数，那就是 Mainline 版本，比如 1.16.0。

对于 NGINX 开源，“稳定”一词指的是功能和更新频率，而不是软件质量。稳定分支在其生命周期中从不接收新功能，通常只接收一两个更新，用于关键错误修复。

stable 版本代表功能多少和更新频率，和软件质量没有太大的关系（当然任何软件都会有Bug）。

在每年4月份会发布一次，它的生命周期是一年，在这段时间内，一般情况不会更新版本号（除非有重大Bug）。

https://www.cnblogs.com/91donkey/p/11639355.html





# 安装 Nginx 和 OpenResty

在 Linux 上，当然可以使用 yum、apt-get 等软件包管理工具来下载 Nginx，但是 Nginx 的很多模块并不是默认开启的，第三方模块很多也并不包含。

所以，如果想要开启内置的模块或编译第三方模块，还是需要编译 Nginx。



### 包管理器安装 nginx

------

```shell
# https://www.nginx.com/resources/wiki/start/topics/tutorials/install/

# 配置yum源：/etc/yum.repos.d/nginx.repo 

# CentOS
[nginx]
name=nginx repo
# 系统:CentOS7 架构:x86_64
baseurl=https://nginx.org/packages/centos/7/x86_64/

# 系统:CentOS8 架构:x86_64
# baseurl=https://nginx.org/packages/centos/7/x86_64/

# 系统:RHEL7 架构:x86_64
# baseurl=https://nginx.org/packages/rhel/7/x86_64/

# 系统:RHEL8 架构:x86_64
# baseurl=https://nginx.org/packages/rhel/7/x86_64/
gpgcheck=0
enabled=1


```



### 编译安装Nginx

在 <http://nginx.org/en/download.html> 里面可以直接下载 Nginx 源代码。包含以下目录：

```shell
# 添加运行nginx的用户
groupadd nginx
useradd -r -g nginx -s /bin/false nginx


# 安装依赖环境，确保编译正常
sudo yum install gcc gcc-c++ make automake autoconf libtool pcre* zlib openssl openssl-devel  pcre pcre-devel

sudo apt install zlib1g zlib1g-dev

# 在 http://nginx.org/en/download.html 里面下载 Nginx 源代码，永远下载最新的Stable release版本
wget http://nginx.org/download/nginx-1.21.6.tar.gz


# https://www.cnblogs.com/chrdai/p/11306728.html
nginx-1.21.4
├── CHANGES 		# 每个版本提供的特性和 bugfix，changelog文件
├── CHANGES.ru 		# 俄罗斯版本的 CHANGES 文件
├── LICENSE			# 开源许可文件
├── Makefile        #    
├── README          # README说明文件
├── auto # 自动检测系统环境以及编译相关的脚本，辅助 configure 脚本执行的时候去判定nginx支持哪些模块，当前操作系统有什么样的特性可以供给nginx使用
├── conf # 示例文件，方便运维配置，会把 conf 示例文件拷贝到安装目录
├── configure # 命令脚本，用来生成中间文件，执行编译前的一个必备动作
├── contrib # 提供了两个 pl 脚本和 vim 工具
├── html # 一个 500 错误的默认页面，另一个是默认的 index 页面
├── man # nginx 对 Linux 的帮助文件，man ./nginx.8
└── src # nginx 核心源代码


# 配置 Vim 高亮, 如果 Vim 没有开启语法高亮的话，最好开启一下
cp -r contrib/vim/* ~/.vim
echo 'syntax on' > ~/.vimrc 


# configure配置，configure之后，会生成Makefile文件，用于编译和构建nginx
./configure   --user=nginx --group=nginx  --prefix=/usr/local/nginx/  --with-http_stub_status_module  --with-http_ssl_module

./configure --help # --help 命令可以查看配置脚本支持哪些参数

# 第一类配置参数

--prefix=PATH                      set installation prefix      # 一般指定这个路径就可以了，其他文件会在 prefix 目录下建立相应的文件夹
--sbin-path=PATH                   set nginx binary pathname
--modules-path=PATH                set modules path
--conf-path=PATH                   set nginx.conf pathname
--error-log-path=PATH              set error log pathname
--pid-path=PATH                    set nginx.pid pathname
--lock-path=PATH                   set nginx.lock pathname
--user=USER                        set non-privileged user for worker processes
--group=GROUP                      set non-privileged group for worker processes
--build=NAME                       set build name
--builddir=DIR                     set build directory



# 第二类配置参数
# 可以配置使用或不使用哪些模块，前缀通常是 with 和 with out。
## with开头的表示该模块默认是未开启的，可以使用--with开启。
## without开头的表示该模块默认是启用的，可以使用--without禁用。
## 第三方模块使用--add-module=PATH添加。如果支持动态加载，使用--add-dynamic-module=PATH添加。

--with-http_ssl_module             enable ngx_http_ssl_module
--with-http_v2_module              enable ngx_http_v2_module
--with-http_realip_module          enable ngx_http_realip_module
...
--without-http_charset_module      disable ngx_http_charset_module
--without-http_gzip_module         disable ngx_http_gzip_module
--without-http_ssi_module          disable ngx_http_ssi_module
...


make && make install 



# nginx服务配置文件，使用systemd
# /lib/systemd/system/nginx.service
# https://www.nginx.com/resources/wiki/start/topics/examples/systemd/

[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target
[Service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid
ExecStartPre=/usr/local/nginx/sbin/nginx -t
ExecStart=/usr/local/nginx/sbin/nginx
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true
[Install]
WantedBy=multi-user.target



# ubuntu

sudo apt-get install gcc make libpcre3 libpcre3-dev   zlib1g-dev openssl libssl-dev 

```



**配置 Vim**

如果 Vim 没有开启语法高亮的话，最好开启一下

```shell
cp -r contrib/vim/* ~/.vim
# mac 下需要在家目录下新建 .vimrc 文件并配置
syntax on
```



### 编译 Nginx

```shell
./configure --help # --help 命令可以查看配置脚本支持哪些参数


# 第一类配置参数

--prefix=PATH                      set installation prefix # 指定这个路径就可以了，其他文件会在 prefix 目录下建立相应的文件夹
--sbin-path=PATH                   set nginx binary pathname
--modules-path=PATH                set modules path
--conf-path=PATH                   set nginx.conf pathname
--error-log-path=PATH              set error log pathname
--pid-path=PATH                    set nginx.pid pathname
--lock-path=PATH                   set nginx.lock pathname
--user=USER                        set non-privileged user for worker processes
--group=GROUP                      set non-privileged group for worker processes
--build=NAME                       set build name
--builddir=DIR                     set build directory



# 第二类配置参数
# 可以配置使用或不使用哪些模块，前缀通常是 with 和 with out，需要加 with 参数的通常是不会被 Nginx 默认编译的，without 则是会移出编译。

--with-http_ssl_module             enable ngx_http_ssl_module
--with-http_v2_module              enable ngx_http_v2_module
--with-http_realip_module          enable ngx_http_realip_module
...

--without-http_charset_module      disable ngx_http_charset_module
--without-http_gzip_module         disable ngx_http_gzip_module
--without-http_ssi_module          disable ngx_http_ssi_module
...





 # 1. 使用默认参数，进行 configure 指定编译安装目录
./configure --prefix=/usr/localnginx/
 # 编译完成后生成 objs 文件夹中间文件
➜   ls -al 
total 176
-rw-r--r--  1 mtdp  staff    40K  3  3 07:23 Makefile
-rw-r--r--  1 mtdp  staff    25K  3  3 07:23 autoconf.err
-rw-r--r--  1 mtdp  staff   5.4K  3  3 07:23 ngx_auto_config.h
-rw-r--r--  1 mtdp  staff   531B  3  3 07:23 ngx_auto_headers.h
-rw-r--r--  1 mtdp  staff   5.7K  3  3 07:23 ngx_modules.c # ngx_modules.c 决定了接下来的编译会生成哪些模块
drwxr-xr-x  9 mtdp  staff   288B  3  3 07:23 src
2. # 编译
make # 生成了大量的中间文件。如果是版本升级，就不能直接 makeinstall，需要将 obj 拷贝到安装目录。如果生成了动态模块，编译后也会放在 objs 目录下
3. # 安装
make install
➜  nginx ll # 安装完成后生成以下文件夹
total 0
drwxr-xr-x  17 mtdp  staff   544B  3  3 07:29 conf # 从 Nginx 源码目录拷贝的
drwxr-xr-x@  4 mtdp  staff   128B  3  3 07:29 html # 从 Nginx 源码目录拷贝的
drwxr-xr-x   2 mtdp  staff    64B  3  3 07:29 logs # 日志文件目录，包括 access log 和 error log
drwxr-xr-x   3 mtdp  staff    96B  3  3 07:29 sbin # Nginx 二进制文件目录
```



### Nginx 安装第三方模块

第三模块是对nginx 的功能扩展，第三方模块需要在编译安装nginx 的时候使用参数--add-module=PATH指定路径添加。

有的模块是由公司的开发人员针对业务需求定制开发的。

有的模块是开源爱好者开发好之后上传到github进行开源的模块，nginx支持第三方模块，需要重新编译源码才能支持。



**安装nginx安装第三方模块** 实际上是使用--add-module重新编译**安装**一次**nginx**，

不要 make install 而是直接把编译目录下 objs/**nginx **文件直接覆盖老的 **nginx **文件。如果你需要**安装**多个**nginx第三方模块**,你只需要多指定几个相应的--add-module即可



### 编译 OpenResty

OpenResty 的编译安装步骤与 Nginx 基本一致

在 <https://openresty.org/en/download.html> 中下载 OpenResty 的源代码，然后按照 Nginx 的编译步骤执行即可。

```bash
wget  https://openresty.org/download/openresty-1.21.4.1.tar.gz
```







# Nginx 配置文件





```nginx
events {
    worker_connections 1024;
}

http {
    #incloud mime.types;
    #default_type application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log logs/geek.access.log main;
    sendfile on;
    #tcp_nopush on;
    #keepalive_timeout 0;
    keepalive_timeout 65;

    gzip on;
    gzip_min_length 1;
    gzip_comp_level 2;
    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png multipart/form-data;
    server {
        listen 8080;
        server_name 127.0.0.1;
        #charset koi8-r;
        access_log logs/geek.access.log main;
        location /lua {
            default_type text/html;
            content_by_lua '
			ngx.say("User-Agent: ", ngx.req.get_headers()["User-Agent"])
			';
			}
        }
        #error_page 404 /404.html;

    }
```





如上所示，是一个非典型的 Nginx 配置文件，Nginx 的配置文件语法遵循以下规则：

- 配置文件由指令与指令块构成
- 每条指令以 ; 结尾，指令与指令的参数之间以空格符号分割
- 指令块以 {} 将多条指令组织在一起

```
events { # 指令块
    worker_connections 1024; # 指令
}
```

- include 语句允许组合多个配置文件，以提升可维护性
- 使用 # 添加注释
- 使用 $ 符号添加变量
- 部分指令的参数支持正则表达式

## 配置参数

### 时间单位

- ms：毫秒
- s：秒
- m：分钟
- h：小时
- d：天
- M：月 = 30 天
- y：年 = 365 天

### 空间单位

- bytes
- k/K：kilobytes
- m/M：megabytes
- g/G：gigabytes

## HTTP 配置的指令块

- http：表示由 http 模块来处理请求
- upstream：表示上游服务器地址
- server：表示站点地址
- location：表示 URL

这些指令块在接下来都会遇到。







# Nginx 命令行

在刚刚编译完成的 Nginx 目录下，有一个 sbin 目录，就是用来存放 Nginx 的二进制文件的

```
➜  sbin ll
total 1712
-rwxr-xr-x  1 mtdp  staff   854K  3  3 07:29 nginx
```

Nginx 启动时，有一系列的命令行参数可以指定，下面分别介绍一下。

```
./nginx
-h/-? # 打开帮助
-c # 使用指定的配置文件，而不是默认的 conf 文件夹下的配置文件
-g # 指定配置命令，覆盖掉配置文件中的指令
-p # 指定运行目录
-s # 发送信号 stop 立刻停止服务；quit 优雅的停止服务；reload 重载配置文件；reopen 重新开始记录日志文件
-t/-T # 测试配置文件是否有语法错误
-v/-V # 打印 nginx 的版本信息、编译信息等
```



## 热部署

当配置文件发生变更时，需要重载配置文件：

```
nginx -s reload
```



# 升级

但想要更换或者升级 nginx 版本时，就需要采用热部署的方式：

1. 查看现有 master 进程的 pid。可以看出来，worker 进程是 master 进程的子进程





# Nginx 配置指令





nginx.conf 文件是 nginx 中的核心文件，用于控制 nginx 的运行。



一个典型的 nginx 配置文件如下：

```nginx
main

http {
    upstream { … }
    split_clients {…}
    map {…}
    geo {…}
    server {
        if () {…}
        location {
            limit_except {…}
        }
        location {
            location {
            }
        }
    }
    server {
    }
}
```





## 指令块的嵌套



在 Nginx 配置文件中，指令块是可以嵌套分层的，例如上面的示例，http 块中可以包含多个 server 块，server 块中还会包含多个 location 块，每一个块中都有相应的指令。



而每一个指令都有 Context 上下文，也就是生效的环境，这在 Nginx 的官方文档中说的很清楚，例如下面的两条指令，Context 中都表明了各自可以生效的环境，access_log 指令可以在多个上下文中生效：



```nginx
Syntax:  access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];
         access_log off;
Default: access_log logs/access.log combined; 
Context: http, server, location, if in location, limit_except

Syntax:  log_format name [escape=default|json|none] string ...;
Default: log_format combined "..."; 
Context: http
```





## 指令的继承



既然 nginx 指令是可以嵌套分层的，而且指令可以存在于多个上下文环境。所以必然存在指令的继承。

例如下面的配置文件，这里面在 server 块和 location 块中都配置了 root 指令，Nginx 的继承规则如下：

- 子配置不存在时，直接使用父配置块的指令
- 子配置存在时，覆盖父配置块



```nginx
server {
    listen 8080;
    root /home/geek/nginx/html;
    access_log logs/geek.access.log main;
    location /test {
        root /home/geek/nginx/test;
        access_log logs/access.test.log main;
    }
    location /dlib {
        alias dlib/;
    }
    location / {
    }
}    
```



根据上面这两条规则，第一个 location 使用自己的 root 指令，后面两个 location 则使用 server 块的 root 指令。

这和编程语言中变量的作用域也是类似的，作用域更小的变量优先级往往更高，Nginx 的指令也是一样。



## 常用 nginx 指令





### http 指令

http 是最顶层的指令之一了，它必须直接在 main 中使用。

```nginx
# 指定运行nginx进程的用户，Default: nobody，
user nginx;  
# 工作进程数，等于CPU核数
worker_processes  auto;  
error_log  logs/error.log;
pid        logs/nginx.pid;
worker_rlimit_nofile 8192;

events {
  worker_connections  4096;  ## Default: 1024
}

http {
  include    conf/mime.types;
  include    /etc/nginx/proxy.conf;
  include    /etc/nginx/fastcgi.conf;
  index    index.html index.htm index.php;

  default_type application/octet-stream;
    
  server { # php/fastcgi
    listen       80;
    server_name  domain1.com www.domain1.com;
    access_log   logs/domain1.access.log  main;
    root         html;

    location ~ \.php$ {
      fastcgi_pass   127.0.0.1:1025;
    }
  }  
    
    server {
       ...
    }
    
}    

```



### server 指令 

server 是 nginx 中最重要的指令了，它必须被包含在 http 指令中使用。一个 server 就定义了一个虚拟主机。http块中可以有多个 server，可以让 nginx 支持多个虚拟主机。

虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。通俗说，一个虚拟主机就是一个网站。

```
Syntax:	server { ... }
Default:	—
Context:	http
```

### server_name 指令

server_name 指令是用来配置究竟是哪个 server 块来处理我们的请求的。它必须在 server 块中使用。

- server_name 指令后可以跟多个域名，第一个是主域名，多个域名之间空格分隔。
- 泛域名：仅支持在最前或最后加 * 通配符匹配任意字符串，例如：`*.demo.com` 和 `test.nginx.*`
- 正则表达式匹配：`server_name www.taohui.tech ~^www\d+\.taohui\.tech$;`



```nginx
Syntax:	server_name name ...;
Default:	
server_name "";
Context:	server
```



nginx 是如何处理一个请求的，假设有这样一个配置文件，配置了三个域名。

```nginx
server {
    listen      80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      80;
    server_name example.com www.example.com;
    ...
}
```

当 nginx 接收到 http 请求时，先从请求头提取到 Host 头部字段，然后跟 server_name 匹配来确认是哪个server块来处理请求。

如果都不匹配，那么就用这个端口号的 default server 来处理。

在这个例子中，就是第一个来处理。——这是nginx的标准做法。也可以在端口号后面加上一个 default_server 来显示指定这个行为。

```nginx
server {
    listen      80 default_server;
    server_name example.net www.example.net;
    ...
}
```

**注意在这个配置中，default_server只是跟在端口后面，并没有配置在域名上面。 **



对于请求头中没有Host头部的请求，如果要禁止访问，可以设置如下配置：没有host头部的请求就会被这个server匹配上，并返回非标准的444状态码关闭连接。

```nginx
# 
server {
    listen      80 default_server;
    server_name "";
    return      444;
}
```





### listen 指令

listen 指令在 server 块中生效，用来配置监听哪些网络接口地址，哪些端口，由这些端口来处理请求。listen 指令的配置语法如下：

```nginx
Syntax:	listen address[:port] [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
listen port [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
listen unix:path [default_server] [ssl] [http2 | spdy] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];

# 默认值
Default:	 listen *:80 | *:8000;

# 只能出现在server块中
Context:	server



# 常见的litsen配置语法

listen 443 ssl http2; # 监听443，开启https，开启http2协议
# 对于nginx1.25之后，需要用单独的指令"http2 on"这样来配置，不支持在litsen后面这样写了。
# 参见：http://nginx.org/en/docs/http/ngx_http_v2_module.html


listen 127.0.0.1:8080;
listen 8080;
listen *:8080;
listen *:8080;



```







### location指令

nginx官方文档给出location语法如下：

```nginx
location [=|~|~*|^~] uri {
	...
}
```





| 标识符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| =      | **精确匹配**；用于标准uri前，要求请求字符串和uri严格匹配。如果匹配成功，就停止匹配，立即执行该location里面的请求。 |
| ~      | **正则匹配**；用于正则uri前，表示uri里面包含正则，并且区分大小写。 |
| ~*     | **正则匹配**；用于正则uri前，表示uri里面包含正则，不区分大小写。 |
| ^~     | **非正则匹配**；用于标准uri前，nginx服务器匹配到前缀最多的uri后就结束，该模式匹配成功后，不会使用正则匹配。 |
| 无     | **普通匹配（最长字符匹配）**；与location顺序无关，是按照匹配的长短来取匹配结果。若完全匹配，就停止匹配。 |



```nginx
location = / {  
   //精确匹配/ ，主机名后面不能带任何字符串
    echo "规则A";
}

location = /login {
  //精确匹配 /login 开头的地址，匹配符合以后，不在继续往下搜索 
    echo "规则B";
}

location ^~ /blog/ { 
  //非正则匹配，匹配/blog/后，停止往下搜索正则，采用这一条
  echo "规则C";
}
 
location ~  \.(gif|jpg|png|js|css)$ {
    //区分大小写的正则匹配  若匹配成功，停止往下搜索正则，采用这一条
    echo "规则D";
}

location ~* \.png$ {  
   //区分大小写的正则匹配 ，停止往下搜索正则，采用这一条
    echo "规则E";
}
 
location / {
  //因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求
  //如果没任何规则匹配上，就采用这条规则
    echo "规则F";
}
 
location /blog/detail { 
  //最长字符串匹配，若完全匹配成功，就不在继续匹配，否则还会进行正则匹配
  echo "规则G";
}
 
location /images {  
    //最长字符串匹配，同上 
    echo "规则Y";
}
 
location ^~ /static/files {  
    //非正则匹配，若匹配成功，就不在继续匹配
    echo "规则X";
```



- 当访问根路径/的时候，比如https://www.fengzhao.me/ ，会匹配规则A。

- 当访问http://www.fengzhao.me/login ，会匹配规则B。

- 当访问http://www.fengzhao.me/login.html ，会匹配规则F。

- 当访问http://www.fengzhao.me/blog/detail/3.html ，会匹配规则C。

分析思路，首先看看，“**精确匹配**”是否可以匹配成功，显示不可以；然后，看看是否可以“**普通匹配**”是否可以完全匹配，显示也没有；接着在看看非正则匹配，是否可以匹配成功，发现同规则C匹配上了，所以采用了规则C。



## ngx_http_upstream_module 模块





# Nginx热升级



https://blog.csdn.net/gexiaoyizhimei/article/details/101650717

https://www.cnblogs.com/wupeixuan/p/12074007.html





# Nginx 安全配置规范



## 禁止IP访问

 一台服务器部署多个网站的时候，为了确保用户访问特定的网站，就要求用户使用域名访问，不能使用IP；另外，也可以防止一些未备案的域名解析到服务器，导入服务器被断网。 







## 隐藏版本号





# Nginx 反向代理和负载均衡



四层和七层负载均衡

- 所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡；同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。

- 二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址；
- 三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；
- 四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器；
- 七层通过虚拟的 URL 或 主机名 接收请求，然后再分配到真实的服务器。



我们最常见的 nginx location proxy_pass 反向代理，就是基于 URL 匹配将 HTTP 请求转到真实的后端服务。





### 在nginx内部处理3xx跳转



nginx反向代理，后端服务器可能返回 3XX 的redirect的response, Nginx会把这个请求直接返回给客户端。

现在我们的需求是让Nginx自己处理这个跳转，而客户端无感知。



### nginx负载均衡算法



#### **轮询 （round-robin）**

轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。

假设配置文件中共有 $M$ 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。

**特点**：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。



#### 加权轮询

```nginx
# 定义一个后端服务，由三个节点组成
upstream cluster  {
    server backend1-inc.example.com        weight=5;
    server backend2-inc.example.com:8080;
    server unix:/tmp/backend3;

    server backup1.example.com:8080   backup;
    server backup2.example.com:8080   backup;
}

server {
   location / {
   		proxy_set_header X-Real-IP $remote_addr;               //返回真实IP
   		proxy_pass http://cluster;                             //代理指向cluster 
    
}
}
```







**上游**

upstream 即上游的意思，是一个想对到概念，从客户端到中间的网络链路到服务器到链路中，可以将越接近客户到设备越理解成下游，相反到为上游。

所以如果只有一个upstream，可以将其为理解成转发客户到请求到服务器，然后响应服务器转发到客户端到过程。

**下游**





 `ngx_http_proxy_module` 模块可以使发到 nginx 的请求转发到真正的另外一个后端服务器上。





**反向代理时的头部处理**



在实际应用中，我们的后端服务器可能需要获取客户端用户的 ip 地址，比如做异地登陆的判断，或者统计 ip 访问次数等，通常情况下我们使用 request.getRemoteAddr() 就可以获取到客户端 ip。

但是当我们使用了 nginx 作为反向代理后，使用 request.getRemoteAddr() 获取到的就一直是 nginx 服务器的 ip 的地址。

经过反向代理后，由于在客户端和 web 服务器之间增加了中间层，因此 web 服务器无法直接拿到客户端的 ip，通过 $remote_addr 变量拿到的将是反向代理服务器的 ip 地址。



如果服务是直接暴露在公网上，根据TCP的原理通过socket是可以拿到真实的用户IP的。但是为了安全性和负载均衡的需要我们很少会直接把后端服务直接放在公网上，通常会在服务前置`Nginx`、`Haproxy`等反向代理软件，有时为了需要还会加多层代理，比如CDN和WAF等，这时如何能获取到用户的IP就成了问题，因为根据TCP的原理，反向代理时上一层和下一层代理建连，后层代理只能获取到上一层代理的IP，没法获取到用户的源IP。





`X-Forwarded-For`是 HTTP头的一个字段，最开始是由 `Squid`这个缓存代理软件引入，在客户端访问服务器的过程中如果需要经过HTTP代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的IP地址，如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用。 [RFC 7239](http://tools.ietf.org/html/rfc7239)（Forwarded HTTP Extension）是这个头信息的标准化版本。



X-Forwarded-For 格式：

```shell
X-Forwarded-For: <client>, <proxy1>, <proxy2>
```



- client：客户端的IP地址。
- proxy1, proxy2：如果一个请求经过了多个代理服务器，那么每一个代理服务器的IP地址都会被依次记录在内。也就是说，最右端的IP地址表示最近通过的代理服务器，而最左端的IP地址表示最初发起请求的客户端的IP地址。



**`X-Forwarded-For`只规定了这个字段的格式，并不代表这是代理服务器的默认行为，是否增加还要是具体配置。**



#### Nginx 处理 X-Forwarded-For

Nginx做反向代理时为了让后端服务能获取到真实的用户ip网上的教程大多会让增加下边两行配置：

```nginx
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
```

**$proxy_add_x_forwarded_for 变量的含义**

- 如果请求中不带X-Forwarded-For头，那么取`$remote_addr`的值；
- 如果请求中带X-Forwarded-For头，那么在X-Forwarded-For后追加`$remote_addr`，即: `X-Forwarded-For,$remote_addr`



因为`X-Forwarded-For`只是一个http的请求头，客户端很容易伪造一个 X-Forwarded-For 请求头。这时`Nginx`如果使用上边的配置的话由于`X-Forwarded-For`不为空，所以`Nginx`只会在现在值的基础上追加，这样后端服务在拿到头后根据约定取最左边ip话就会拿到一个伪造的IP，会有安全风险。

```shell
curl -H "X-Forwarded-For: 8.8.8.8" https://www.google.com 
```

由于请求头是不可靠的，我们不能信任客户端传过来头信息，那么如何解决呢？



TCP不像UDP必须经过3次握手，客户端的IP是无法伪造的，所以**最外层的代理**一定要取`$remote_addr`的值，对应配置：

```nginx
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $remote_addr;
```







# 初探 nginx 架构



nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。

我们也可以手动地关掉后台模式，让 nginx 在前台运行，并且通过配置让 nginx 取消 master 进程，从而可以使 nginx 以单进程方式运行。

很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的，在后面的章节里面，我们会详细地讲解如何调试nginx。

**nginx是以多进程的方式来工作的，当然nginx也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是nginx的默认方式。**





nginx在启动后，会有一个master进程和多个worker进程。

- master进程主要用来管理worker进程，包含：
  - 接收来自外界的信号，向各worker进程发送信号。比如 reload 重载配置文件，重启nginx等。
  - 监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。

- worker进程：
  - 真正的工作进程，处理网络请求事件。各进程互相之间是独立的。
  - 一个请求，只可能在一个worker进程中处理。



**worker进程的个数是可以设置的，一般我们会设置与机器cpu核数一致。**



master来管理worker进程，所以我们只需要与master进程通信就行了。master进程会接收来自外界发来的信号，再根据信号做不同的事情。

所以我们要控制nginx，只需要通过kill向master进程发送信号就行了。比如kill -HUP pid，则是告诉nginx，从容地重启nginx，我们一般用这个信号来重启nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。

master进程在接收到HUP信号后是怎么做的呢？首先master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。当然，直接给master进程发送信号，这是比较老的操作方式，nginx在0.8版本之后，引入了一系列命令行参数，来方便我们管理。比如，./nginx -s reload，就是来重启nginx，./nginx -s stop，就是来停止nginx的运行。如何做到的呢？我们还是拿reload来说，我们看到，执行命令时，我们是启动一个新的nginx进程，而新的nginx进程在解析到reload参数后，就知道我们的目的是控制nginx来重新加载配置文件了，它会向master进程发送信号，然后接下来的动作，就和我们直接向master进程发送信号一样了。







异步非阻塞



一个请求的完整过程。首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。

具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧





# Nginx基础概念

















# nginx 第三方模块







## 访问控制



### GEOIP访问控制

对于在公网部署的应用，需要通过检测访问者的 IP ，来决定转发策略，或者是否访问。可以采用  ngx_http_geoip2_module 模块。

GeoIP2 是 MaxMind 公司推出的知名 IP 定位数据库，数据库每周更新。可以通过 [github](https://github.com/fengzhao-study-notes/maxmind-geoip/releases) 下载。



利用访问

nginx的版本比较重要，低于`1.9.11`版本的nginx无法使用动态模块，低于`1.11.5`版本的nginx编译动态模块时不支持`--with-compat`兼容参数，所以请保证您的nginx版本不低于`1.11.5`。



ngx_http_geoip2_module 





```shell
# 如果nginx是编译安装的，可以用nginx -V查看nginx源版本和编译参数

[root@stxz-elk-01 nginx-1.21.4]#
[root@stxz-elk-01 nginx-1.21.4]# /usr/local/nginx/sbin/nginx  -V
nginx version: nginx/1.21.4
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)
built with OpenSSL 1.0.2k-fips  26 Jan 2017
TLS SNI support enabled
configure arguments: --user=nginx --group=nginx --prefix=/usr/local/nginx/ --with-http_stub_status_module --with-http_ssl_module
[root@stxz-elk-01 nginx-1.21.4]#


# 下载对应版本的nginx源代码，然后


 ./configure                                     \
 --user=nginx --group=nginx                      \
 --prefix=/usr/local/nginx/                      \
 --with-http_stub_status_module                  \
 --with-http_ssl_module                          \
 --add-dynamic-module=./ngx_http_geoip2_module   \
 --with-stream                                   \
 --with-compat






wget -O /usr/local/nginx/geo/GeoLiteCountry.mmdb  https://github.com/fengzhao-study-notes/maxmind-geoip/releases/download/20220301/Country.mmdb


wget -O /usr/local/nginx/geo/GeoLiteCity.mmdb https://github.com/fengzhao-study-notes/maxmind-geoip/releases/download/20220301/City.mmdb


wget -O /usr/local/nginx/geo/GeoLiteASN.mmdb https://github.com/fengzhao-study-notes/maxmind-geoip/releases/download/20220301/ASN.mmdb



```





# nginx事件驱动模型



事件驱动模型是Nginx服务器保障完整功能和具有良好性能的重要机制之一。









### 惊群效应

当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。

**这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。**

简单地说：就是扔一块食物，所有鸽子来抢，但最终只一个鸽子抢到了食物。

**语义分析：食物只有一块，最终只有一个鸽子抢到，但是惊动了所有鸽子，每个鸽子都跑过来，消耗了每个鸽子的能量。**

**（这个很符合达尔文的进化论，物种之间的竞争，适者生存。）**

在多进程/多线程等待同一资源时，也会出现惊群。即当某一资源可用时，多个进程/线程会惊醒，竞争资源。这就是操作系统中的惊群。





"惊群"简单地来讲，就是多个进程(线程)阻塞睡眠在某个系统调用上，在等待某个 fd(socket)的事件的到来。

当这个 fd(socket)的事件发生的时候，这些睡眠的进程(线程)就会被同时唤醒，多个进程(线程)从阻塞的系统调用上返回，这就是"惊群"现象。

**"惊群"被人诟病的是效率低下，大量的 CPU 时间浪费在被唤醒发现无事可做，然后又继续睡眠的反复切换上。**





