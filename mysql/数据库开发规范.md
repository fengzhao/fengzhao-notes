# MySQL数据库规范



## 1. 文档定义



### 1.1 编写目的

为了在软件生命周期内规范数据库相关的需求分析、设计、开发、测试、运维工作便于不同团队之间的沟通协调，以及在相关规范上达成共识，提升相关环节的工作效率和系统的可维护性。同时好的规范，在执行的时候可以培养出好的习惯，好的习惯是软件质量的保证。

### 1.2 适用范围





## 2. 命名规范

### 2.1 总则

1. 所有的数据库对象名称(包括库名、表名、列名等等)必须以小写字母命名，每个单词之间用下划线分割。

   MySQL 在 Windows 下不区分大小写，但在 Linux 下默认是区分大小写，因此，数据库名、表名、字段名，都不允许出现任何大写字母，避免节外生枝

2. 所有数据库对象名称禁止使用MySQL保留关键字，中文字符，特殊字符，空格，中英拼音混用等。

3. 数据库对象的命名要能做到见名知意，并且不要超过25个字符。

4. 数据库中用到的临时表以tmp加日期为后缀。

5. 数据库中用到的备份表以bak加日期为后缀。

6. 在不同的库或表中，要保证所有存储相同数据的列名和列类型必须一致。

### 2.2 库名

库名与应用名称尽量一致，统一小写，以下划线分割。

### 2.3 表名

表名必须使用小写字母或数字，以下划线分割，禁止出现数字开头，禁止两个下划线中间只出现数字。

如果表名仅有一个单词，那么建议不使用缩写，而是用完整的单词。同一模块的表尽可能使用相同的前缀，表名称尽可能表达含义。

- 数据表 <模块标识>_<表标识> 例如： order_header , order_detail

- 编码表 base\_<模块标识>\_<表标识>

- 日志表 log\_<模块标识>\_<表标识>

### 2.4 字段名

（1） 能表达字段功能的英文单词或单词缩写，一般不超过三个英文单词，以下划线分割。布尔类型的字段以“is_”作为前缀。

（2） 各表之间意义相同的字段应同名。

（3） 系统中所有属于内码的字段（仅用于表示唯一性和程序内部用到的标识性字段），名称取为：<表标识>_id。

（4） 系统中属于是业务范围内的编号的字段，其代表一定的业务信息，这样的字段建议命名为<业务标识>_code，其数据类型为VARCHAR，该字段需加唯一索引。

（5） 字段名不要与表名重复。

（6） 不要在列的名称中包含数据类型。

（7） 每个字段添加字段说明。

（8） 数据库字段名的修改代价很大，所以字段名称需要慎重考虑。

（9） 统一命名字段：create_by、create_time、modify_by、modify_time、disabled

### 2.5 索引名 

A. 非唯一索引必须按照“idx_<构成索引的字段名>”进行命名 

例如：在age上添加索引idx_age

B. 唯一索引必须按照“uidx_<构成索引的字段名>”进行命名

例如：uidx_cardid

C. 组合索引建议包含所有字段名，过长的字段名可以采⽤缩写形式

例如：idx_age_name

### 2.6 视图命名 

v\_<模块标识>\_<视图标识> 

### 2.7 存储过程命名 

usp\_<模块标识>\_<存储过程标识> 

### 2.8 函数命名 

ufn\_<模块标识>\_<函数标识> 



## 3. 数据库设计规范

### 3.1 表设计原则

2. 建议表使用InnoDB存储引擎，nnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。

3. 同一个DB中的表，其存储引擎、字符集应保持统一，建库建表时尽量显式指定utf8mb4 字符集，数据表字段加中文注释。

   - **数据表创建、变更时必须提供数据表设计文档: 包含表及字段详细说明**

3. 规范化与反规范化

   - 规范化的优点是减少了数据冗余，节约了存储空间，相应逻辑和物理的I/O次数减少，同时加快了增、删、改的速度。但是一个完全规范化的设计并不总能生成最优的性能，因为对数据库查询通常需要更多的连接操作，从而影响到查询的速度，而且范式越高性能就会越差。出于性能和方便管理的考虑，原则上表设计应满足第三范式。**有时为了提高某些查询或应用的性能而可以破坏规范规则，即反规范化。数据应当按两种类别进行组织：频繁访问的数据和频繁修改的数据。对于频繁访问但是不频繁修改的数据，内部设计应当物理不规范化。对于频繁修改但并不频繁访问的数据，内部设计应当物理规范化。**比较复杂的方法是将规范化的表作为逻辑数据库设计的基础，然后再根据整个应用系统的需要，物理地非规范化数据。

4. 每个表必须要有主键，Innodb是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。数据存储默认是按照主键排序。

   不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引） 不要使用UUID、MD5、HASH、字符串列作为主键（无法保证数据的顺序增长）。

5. 优先为表中的每一列选择符合存储需要的最小的数据类型：

   设计时尽量使用少的空间存储字段，如能用 int 的就不用 char 或者 varchar、能用 tinyint 的就不用 int 、能用 varchar(20) 的就不用 varchar(255)。

   列的字段类型越大，建立索引占据的空间就越大，导致一个页中的索引越少，造成IO次数增加，影响性能。

6. 控制单表数据量的大小，建议控制在 500 万行以内。

   可以采用历史数据归档(常见于日志表)和分库分表的方式控制单表数据的大小。

7. 禁止在表中建立预留字段。
   修改列的类型会所锁表。修改一个字段类型的成本要高于增加一个字段。

8. VARCHAR(N)，N表示的是字符数不是字节数，比如 VARCHAR(255)，可以最大可存储255个汉字，需要根据实际的宽度来选择N。

9. VARCHAR(N)，N尽可能小，因为MySQL一个表中所有的VARCHAR字段最大长度是65535个字节，进行排序和创建临时表一类的内存操作时，会使用N的长度申请内存。

10. 存储年使用YEAR类型。

11. 存储日期（年月日）使用DATE类型。

12. 存储时间（年月日时分秒）建议使用TIMESTAMP类型，因为TIMESTAMP使用4字节，DATETIME使用8个字节。

    TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07。

13. 每个字段尽可能具有NOT NULL属性。

    因为NULL值的存储需要额外的空间，且会导致比较运算更为复杂，会使得优化器更难以优化sql。

14. 适当进行**反范式化设计，便于查询和索引优化**。

    字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：不是频繁修改的字段；不是 varchar 超长字段；更不能是 text 字段。

15. 表达是与否概念的字段，必须使用 `is_xxx` 的方式命名，数据类型是 `UNSIGNED TINYINT`

16. join 操作的字段，在不同表中的类型及命名要一致。

17. 尽可能不要使用text,blob类型

## 索引设计规范

1. 限制每张表上的索引数量，建议单张表索引不超过5个。

   索引并不是越多越好。索引可以提高查询的效率，但会降低写数据的效率。有时不好的索引还会降低查询的效率。

2. 避免冗余的索引，如：primary key(id)，index(id)，unique index(id)

3. 避免重复的索引，如：index(a,b,c)，index(a,b)，index(a)

   重复的和冗余的索引会降低查询效率，因为MySQL查询优化器会不知道该使用哪个索引。

4. 在 `VARCHAR` 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据 实际文本区分度决定索引长度即可。

   一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上。

5. 尽量选择区分度高的字段做索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少。

   使用 `show index from schema.table_name ` 来查看索引区分度。

   区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）；

   尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO性能也就越好）；

   使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）。

6. 对于频繁的查询优先考虑使用覆盖索引。

   覆盖索引：就是包含了所有查询字段(where,select,ordery by,group by 包含的字段)的索引



## SQL语句规范



1. SELECT语句必须指定具体字段名称，避免写成*。因为select * 会将不该读的数据也从MySQL里读出来，造成网卡压力。

2. insert语句指定具体字段名称，不要写成insert into t1 values(…)，道理同上。

3. 事务里批量更新数据需要控制数量，进行必要的sleep，做到少量多次。

4. where条件里等号左右字段类型必须一致，否则无法利用索引。

   **避免数据类型的隐式转换，会导致索引失效**：SELECT name FROM users WHERE id='111'; 

5. 充分利用表上已经存在的索引。

   避免使用双%号的查询条件，如a like ‘%123%’，（如果无前置%,只有后置%，是可以用到列上的索引的）

6. SELECT|UPDATE|DELETE|REPLACE 要有 WHERE 子句，且WHERE子句的条件必需使用索引查找。

7. WHERE 子句中禁止只使用全模糊的LIKE条件进行查找，必须有其他等值或范围查询条件，否则无法利用索引。

8. 减少使用or语句，可将or语句优化为union，然后在各个where条件上建立索引。如where a=1 or b=2优化为where a=1… union …where b=2, key(a),key(b)。

9. 避免使用子查询，可以把子查询优化为join操作

   子查询性能差的原因：子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中；

   特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大；

10. 避免使用JOIN关联太多的表，对于Mysql来说，是存在关联缓存的，缓存的大小可以由join_buffer_size参数进行设置。

    如果程序中大量的使用了多表关联的操作，同时join_buffer_size设置的也不合理的情况下，就容易造成服务器内存溢出的情况，

    MySQL最多允许关联61个表，建议不超过5个。

11. WHERE从句中禁止对列进行函数转换和计算。

    对列进行函数转换或计算时会导致无法使用索引

    不推荐：where date(create_time)=’20190101′

    推荐：where create_time >= ‘20190101’ and create_time < ‘20190102’、

12. 在明显不会有重复值时使用UNION ALL而不是UNION
    - UNION会把两个结果集的所有数据放到临时表中后再进行去重操作
    - UNION ALL不会再对结果集进行去重操作



​    

​    

​    

​    

​    

​    

​    

​    



​    

​    

​     