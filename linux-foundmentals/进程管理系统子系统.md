# 楔子

计算机实际上可以做的事情实质上非常简单，比如计算两个数的和，再比如在内存中寻找到某个地址等等。这些最基础的计算机动作被称为指令 (instruction)。

所谓程序(program)，就是这样一系列指令的所构成的集合。通过程序，我们可以让计算机完成复杂的操作。程序大多数时候被存储为可执行的文件。

这样一个可执行文件就像是一个菜谱，计算机可以按照菜谱作出可口的饭菜。





# 何谓进程？

进程是程序的一个具体实现。只有食谱没什么用，我们总要按照食谱的指点真正一步步实行，才能做出菜肴。

进程是执行程序的过程，类似于按照食谱，真正去做菜的过程。同一个程序可以执行多次，每次都可以在内存中开辟独立的空间来装载，从而产生多个进程。

操作系统的一个重要功能就是为进程提供方便，比如说为进程分配内存空间，管理进程的相关信息等等，就好像是为我们准备好了一个精美的厨房。







不同的进程还可以拥有各自独立的IO接口。



进程就是正在执行的程序代码。但进程并不仅仅局限于一段可执行程序代码（Unix称其为代码段，text section）。

通常进程还要包含其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程（thread of execution），当然还包括用来存放全局变量的数据段等。



进程可以认为是已经被OS从磁盘加载到内存上的、动态的、可运行的指令与数据的集合，是在运行的动态实体。

这里指的指令和数据的集合可以理解为Linux上ELF文件格式中的.text .data数据段。



程序是指的存储在存储设备上（如磁盘）包含了可执行机器指 令（二进制代码）和数据的静态实体



现代计算机硬件包括多CPU和多核单CPU。进程的多个线程可以同时运行在不同的核心之上。

进程与线程最大的区别在于：**进程是操作系统分配资源的最小单位，线程是操作系统调度的最小单位。（这句话一定要深入理解，这是操作系统中最关键的概念）**

**对Linux底层的C库系统调用和内核角度来说，并不区分线程和进程，都是同样的函数调用，只是入参不同。**

所谓内核调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存、全局变量等资源。对于线程和进程我们可以这么理解：

- 资源，就是内存，文件，socket等，
- 当进程只有一个线程时，可以认为进程就等于线程。
- 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
- 另外线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也时需要保存的。

其实线程的上下文切换可以分为两种情况：

- 前后两个线程属于不同进程。此时因为资源不共享，所以切换过程就跟进程上下文切换是一样的。
- 前后两个线程属于同一个进程。此时虚拟内存是共享的，上下文切换时，虚拟内存这些资源保持不动，只需要切换线程的私有数、寄存器等不共享的数据。

可以发现同进程内的线程切换，要比多进程间的切换消耗更少的资源，这也正是多线程代替多进程的一个优势。



## 进程状态（PROCESS STATE CODES）

top 和 ps 是最常用的查看进程状态的工具，top命令输出中的S列（status）就是表示进程状态。

- R 是 Running 或 Runnable 的缩写，表示进程在 CPU 的就绪队列中，正在运行或者正在等待运行。这种状态下进程已经获得CPU使用权，或者已经准备就绪，随时都可以运行。在一些实时操作系统(比如ucos)中，把处于准备就绪的进程称为就绪态，但是Linux把就绪态和运行态都统称为运行态。
- D 是 Disk Sleep 的缩写，也就是不可中断状态睡眠（Uninterruptible Sleep），一般表示进程正在跟硬件交互，并且交互过程不允许被其他进程或中断打断。
- Z 是 Zombie 的缩写。它表示僵尸进程，也就是进程实际上已经结束了，但是父进程还没有回收它的资源（比如进程的描述符、PID 等）。
- S 是 Interruptible Sleep 的缩写，也就是可中断状态睡眠，表示进程因为等待某个事件而被系统挂起。当进程等待的事件发生时，它会被唤醒并进入 R 状态。
- T 是 stopped by job control signal，
- t

Linux上进程有5种状态:

| 进程状态 | 含义                                                | 对应的状态代码 |      |
| -------- | --------------------------------------------------- | -------------- | ---- |
| 运行     | 进程在 CPU 的就绪队列中，正在运行或者正在等待运行。 | R              |      |
| 中断     |                                                     |                |      |
| 不可中断 |                                                     |                |      |
| 僵死     |                                                     |                |      |
| 停止     |                                                     |                |      |

进程的不可中断状态是系统的一种保护机制，可以保证硬件的交互过程不被意外打断。所以，短时间的不可中断状态是很正常的。

**但如果系统或硬件发生了故障，进程可能会长时间处于不可中断状态，甚至导致系统中出现大量不可中断进程。**

**这时，你就得注意下，系统是不是出现了 I/O 等性能问题。**



# 进程号



在 Linux 系统中，每个进程都有一个非负整型表示的唯一进程 ID，虽然在主机级别是唯一的，但是进程的 ID 可以重用，一个进程停止后，其它的进程可以复用该 ID 。

每个进程都有唯一PID，当进程退出运行之后，PID就会回收，可能之后创建的进程会分配这个PID。

Linux中标识进程的一个数字，它的值是不确定的，是由操作系统分配的

（但是有一个例外，启动阶段,kernel运行的第一个进程是init，它的PID是1，是所有进程的最原始的父进程）。



Linux 采用延迟重用的算法，在大部分场景下会使得新进程 ID 不同于最近终止进程所使用的 ID，以防止将新进程误认为是使用同一 ID 的某个已终止的先前进程。

如果编译内核时设置了CONFIG_BASE_SMALL选项，则默认的pid的最大值是0x1000，即4096个，否则默认的最大值是0x8000，即32768个。

默认的最大值是可以修改的，但是可以修改的最大值是多少，这个是通过 PID_MAX_LIMIT限定的。

在 Linux 系统中，内核分配 PID 的范围是 (RESERVED_PIDS, PID_MAX_DEFAULT)，  cat  /proc/sys/kernel/pid_max 查看当前系统最大的PID



内核会为每一个进程分配一个唯一的ID号，这就是进程号PID。

- PID（process ID）： PID是程序被操作系统加载到内存成为进程后动态分配的资源。用来标识运行中的进程。PID是唯一的，一个PID只标识一个进程。 每次程序执行的时候，操作系统都会重新加载，PID在每次加载的时候都是不同的。

- PPID（parent process ID）： PPID是程序的父进程的进程号。

在计算机的上古时代，比如没有网络的 PC 时代，不会有程序员高瞻远瞩的预测到互联网时代的来临，也不会想到一台服务器会创建那么多的进程，即使在互联网初期，一台服务器能有100个在线用户已经是不得了的事情了。甚至，他们在设计 Unix 的 PID 的时候，采用了有符号的16位整数，这就导致一台计算机上能够创建出来的进程无法超过32767个。而计算机自己也得运行一些后台进程，这样应用软件能够创建的进程数就更少了。

当然，这个问题随着技术的发展很快就解决了，现在大部分的个人电脑操作系统可以创建64位的进程，由于数据类型所带来的进程数上限消失了，但是我们依然不能无限制的创建进程。

因为随着并发连接数的上升会占用系统大量的内存，同样会造成系统的不可用。

操作系统里内存管理的主要作用是，进程请求内存的时候为其分配可用内存，进程释放后回收内存，并监控内存的使用状况。

为了提高内存的使用率，现代操作系统需要程序能够共享内存，并且内存的限制对开发者透明，有些程序占用了内存空间，但不一定是一直使用的，这样可以把这部分内存数据序列化到磁盘上，需要的时候再加载到内存里，这样内存资源永远会给最需要的程序使用。于是程序员们发明了虚拟内存（Virtual Memory）。



## 进程组



每个进程除了有一个进程ID之外，还属于一个进程组，那什么是进程组呢？

顾名思义，进程组就是一个或多个进程的集合。这些进程并不是孤立的，他们彼此之间或者存在父子、兄弟关系，或者在功能上有相近的联系。

**每个进程都有父进程，而所有的进程以init进程为根，形成一个树状结构**。

那为啥Linux里要有进程组呢？其实，提供进程组就是为了方便对进程进行管理。假设要完成一个任务，需要同时并发100个进程。

当用户处于某种原因要终止 这个任务时，要是没有进程组，就需要手动的一个个去杀死这100个进程，并且必须要严格按照进程间父子兄弟关系顺序，否则会扰乱进程树。



有了进程组，就可以将这100个进程设置为一个进程组，它们共有1个组号（pgrp），并且有选取一个进程作为组长（通常是“辈分”最高的那个，通常该进程的ID也就作为进程组的ID）。现在就可以通过杀死整个进程组，来关闭这100个进程，并且是严格有序的。

组长进程可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。



## **零号进程和一号进程**

Linux下有3个特殊的进程：

- idle进程(PID = 0)：由系统自动创建, 运行在内核态。其前身是系统创建的第一个进程，也是唯一一个没有通过fork或者kernel_thread产生的进程。
- init进程(PID = 1)：由idle通过kernel_thread创建，在内核空间完成初始化后, 加载init程序, 并最终运行在用户空间。
- kthreadd(PID = 2)：由idle通过kernel_thread创建，并始终运行在内核空间, 负责所有内核线程的调度和管理。

一号进程的可执行文件是/sbin/init ，就是我们常说的init进程，init 0是关机， init 1 init 2 init 3 init 4 等是各种Linux启动级别。



# 进程管理



在一个典型的Windows或 Linux系统中，在计算机完成引导后，会启动40～60个，甚至更多的进程。

例如，当一个Windows应用程序安装后，通常会发出一系列命令，使得在此后的系统引导中会启动一个仅仅用于查看该应用程序更新的进程。

这样一个进程会轻易地占据5～10MB的内存。其他后台进程还会查看所收到的邮件和进来的网络连接，以及其他很多诸如此类的任务。



并且，这一切都发生在第一个用户程序启动之前。当前重要的应用程序能轻易地占据50～200MB甚至更多的空间。

因此，把所有进程一直保存在内存中需要巨大的内存，如果内存不够，就做不到这一点。



有两种处理内存超载的通用方法。最简单的策略是交换（swapping）技术，即把一个进程完整调入内存，使该进程运行一段时间，然后把它存回磁盘。

空闲进程主要存储在磁盘上，所以当它们不运行时就不会占用内存（尽管它们的一些进程会周期性地被唤醒以完成相关工作，然后就又进入睡眠状态）。

另一种策略是虚拟内存（virtual memory），该策略甚至能使程序在只有一部分被调入内存的情况下运行。



## **ps -ef 与 ps aux**

Linux下显示系统进程的命令ps，最常用的有ps -ef 和ps aux。这两个到底有什么区别呢？

- Unix 风格的参数, 前面加单破折线;
- BSD 风格的参数, 前面不加破折线;
- GNU 风格的长参数, 前面加双破折线。

两者没太大差别，讨论这个问题，要追溯到Unix系统中的两种风格：

- System Ｖ风格和BSD 风格，ps aux最初用到Unix Style中。
- ps -ef被用在System V Style中，两者输出略有不同。



现在的大部分Linux系统都是可以同时使用这两种方式的。

ps -ef 是用标准的格式显示进程的、其格式如下:

```text
PROCESS STATE CODES       
Here are the different values that the s, stat and state output specifiers (header "STAT" or "S") will display to describe the state of a process:
               D    uninterruptible sleep (usually IO)
               I    Idle kernel thread
               R    running or runnable (on run queue)
               S    interruptible sleep (waiting for an event to complete)
               T    stopped by job control signal
               t    stopped by debugger during the tracing
               W    paging (not valid since the 2.6.xx kernel)
               X    dead (should never be seen)
               Z    defunct ("zombie") process, terminated but not reaped by its parent

For BSD formats and when the stat keyword is used, additional characters may be displayed:

               <    high-priority (not nice to other users)
               N    low-priority (nice to other users)
               L    has pages locked into memory (for real-time and custom IO)
               s    is a session leader
               l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
               +    is in the foreground process group
```





pgrep是linux中常用的通过程序名字来查询进程的命令。

一般用来查找正在运行进程的PID信息。

常用选项：

- 默认只显示PID

- -l 同时显示进程名和PID

- -o 当匹配多个进程时，显示进程号最小的那个

- -n 当匹配多个进程时，显示进程号最大的那个

注：进程号越大，并不一定意味着进程的启动时间越晚.



# 守护进程和前台进程



**守护进程**

「守护进程」是 Linux 的一种长期运行的后台服务进程，也有人称它为「精灵进程」。

我们常见的 httpd、named、sshd，nginx，mysqld  等服务都是以守护进程 Daemon 方式运行的，通常服务名称以字母ｄ结尾，也就是 Daemon 第一个字母。与普通进程相比它大概有如下特点：

- 无需控制终端(不需要与用户交互)
- 在后台运行
- 生命周期比较长，一般是随系统启动和关闭

为什么要设置为守护进程，普通进程不可以吗？

当我们在命令行提示符后输入类似./helloworld程序时，在程序运行时终端被占用，此时无法执行其它操作。即使使用./helloworld &方式后台运行，当连接终端的网络出现问题，那么也会导致运行程序中断。

这些因素对于长期运行的服务来说很不友好，而「守护进程」可以很好的解决这个问题。



# 进程间通讯

操作系统内的并发执行的进程可以是独立的也可以是协作的。如果一个进程不能影响其他进程或受其他进程影响。那么该进程是独立的。



IPC是进程间通信(interprocess communication)的简称。Linux 进程间通讯，大概有数据传输、共享数据、通知事件、资源共享和进程控制等。

对于每一个进程来说，在这个进程内看到属于它的一块内存资源，这块资源是它所独占的，当出现多进程多线程需要协作时，进程之间的通信就会比较麻烦。

多个进程的内存是相互隔离的，但硬盘，数据库等资源是共享的。

原理就是需要让不同的进程间能够看到一份公共的资源。

所以交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间 拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信。

Linux 下有多种 IPC 机制：

- 管道（PIPE）
- 命名管道（FIFO）
- 信号（Signal）
- 消息队列（Message queues）
- 信号量（Semaphore）
- 共享内存（Share Memory）
- 内存映射（Memory Map）
- 套接字（Socket）



举个例子，我们常见的 MySQL 本地登陆，我们都是 mysql -u root -p'123456' -S /tmp/mysql.sock  这样去登陆。

这其实就可以理解为使用socket套接字的进程间通讯（mysql命令 和 mysql server进程的通讯，执行mysql命令也是启动一个客户端进程） 

我们常见的进程间通讯方式包括：匿名管道（PIPE）、有名管道（FIFO）、消息队列、共享内存、信号、信号量、套接字（socket）。



## 管道

管道(pipe)。管道是第一个广泛使用的IPC形式，是 UNIX 系统IPC最古老的形式。既可在程序中使用，也可以在shell中使用。

匿名管道：管道只能在具有共同祖先(指父子进程关系)的进程间使用。

回忆一下管道符的基本概念（管道符的定义：把上一个进程的输出，当做为下一个进程的输入）

（比如我们在命令中的管道符，其实管道符前后的两句命令的父进程都是当前终端shell进程）

当一个进程向管道中写的内容被管道另一端的进程读出；写入的内容每次都会被添加到管道缓冲区的末尾，并且每次都是从缓冲区的头部读出数据。



有名管道：FIFO。FIFO是管道概念的一个变体，FIFO(First In First Out,先进先出)，也叫有名管道。可以用于任意进程间通信（不一定是亲缘关系的进程）。

socketpair。socket编程接口提供的一个创建全双工管道的系统调用。也被称为流管道。



**管道命令**操作符是：”|”，它把前一个命令的标准输出作为后面一个命令的标准输入。

| **格式**        | **格式**                                                     |
| --------------- | ------------------------------------------------------------ |
| 命令1;命令2     | 多个命令顺序执行，命令之间无任何逻辑关系                     |
| 命令1&&命令2    | 逻辑与：当命令1正确执行后，命令2才会正确执行，否则命令2不会执行 |
| 命令1\|\|命令2  | 逻辑或：当命令1不正确执行后，命令2才会正确执行，否则命令2不会执行 |
| 命令1  \| 命令2 | 命令管道：左边命令的输出就会作为管道符右边命令的输入         |



# **进程信号**

两个直观的感受，你在终端运行一个程序然后摁一下Ctrl+c就是向正在运行的程序发送了一个终止信号，程序就被终止了；

在终端kill一个pid相当于发送9号杀死这个进程；在终端运行kill -l 就可以查看系统的所有信号。

信号本质上是一种向一个进程通知发生异步事件的机制，是在软件层次上对中断的一种模拟。这种通知机制可以用于通知硬件消息，也可以用来进行进程间通信，还可以用来通知一些程序错误如除0、非法内存访问。异步是说进程没有对信号进行实时监控，不必等待信号到来，事实上进程也根本不知道信号什么时候会来。一个进程本来在欢乐的跑着突然就被你一个ctrl+c给杀死了，飞来横祸呀。至于说是一种软中断，是因为在原理上，一个进程受到一个信号与处理器收到一个中断请求可以说是一样的，本来在欢乐的跑着就从你一个脚上给你来一个高电平。

软中断信号 (简称为信号) 是用来通知进程发生了异步事件，是在软件层次上是对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。

信号是进程间通信机制中唯一的异步通信机制，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。

信号是由内核(kernel)管理的。信号的产生方式多种多样，它可以是内核自身产生的，比如出现硬件错误(比如出现分母为0的除法运算，或者出现segmentation fault)，内核需要通知某一进程；

也可以是其它进程产生的，发送给内核，再由内核传递给目标进程。

在 Linux 中，kill 命令就是给进程发送一个信号，实际上就是 Linux 中的进程间通讯，通过信号量的方式。

```bash
# kill命令的用法：kill 信号量  pid （可以跟多个pid）
kill -9 -1
# -1这个pid最为特殊，它表示所有的进程，除了kill本身和init之外。
# 这个强大和危险的命令迫使进程在运行时突然终止，进程在结束后不能自我清理。危害是导致系统资源无法正常释放，一般不推荐使用，除非其他办法都无效。 
# 当使用此命令时，一定要通过ps -ef确认没有剩下任何僵尸进程。只能通过终止父进程来消除僵尸进程。如果僵尸进程被init收养，问题就比较严重了。杀死init进程意味着关闭系统。 
# 如果系统中有僵尸进程，并且其父进程是init，而且僵尸进程占用了大量的系统资源，那么就需要在某个时候重启机器以清除进程表了。

# 信号量一般会从1开始编号，通常来说，信号编号是1到31，这个编号在所有的Unix系统上都是一样的。
# 在Linux上我们可以用 kill -l 来看这些信号的编号和名字。

# SIGTERM（15），这个信号是Linux命令kill缺省发出的。前面例子里的命令 kill 1 ，就是通过kill向1号进程发送一个信号，在没有别的参数时，这个信号类型就默认为SIGTERM。
# SIGTERM这个信号是可以被捕获的，这里的“捕获”指的就是用户进程可以为这个信号注册自己的handler，而这个handler，我们后面会看到，它可以处理进程的graceful-shutdown问题。

# SIGKILL (9)，这个信号是Linux里两个特权信号之一，就是Linux为kernel和超级用户去删除任意进程所保留的，不能被忽略也不能被捕获。那么进程一旦收到SIGKILL，就要退出。
```

进程在收到信号后，就会去做相应的处理。怎么处理呢？对于每一个信号，进程对它的处理都有下面三个选择。

- 第一个选择是**忽略（Ignore）**，就是对这个信号不做任何处理，但是有两个信号例外，对于SIGKILL和SIGSTOP这个两个信号，进程是不能忽略的。这是因为它们的主要作用是为Linux kernel和超级用户提供删除任意进程的特权。
- 第二个选择，就是**捕获（Catch）**，这个是指让用户进程可以注册自己针对这个信号的handler。

**对于捕获，SIGKILL和SIGSTOP这两个信号也同样例外，这两个信号不能有用户自己的处理代码，只能执行系统的缺省行为。**

- 还有一个选择是**缺省行为（Default）**，Linux为每个信号都定义了一个缺省的行为，你可以在Linux系统中运行 man 7 signal来查看每个信号的缺省行为。

对于大部分的信号而言，应用程序不需要注册自己的handler，使用系统缺省定义行为就可以了。

# **进程中断机制**

比如说你订了一份外卖，但是不确定外卖什么时候送到，也没有别的方法了解外卖的进度，但是，配送员送外卖是不等人的，到了你这儿没人取的话，就直接走人了。

所以你只能苦苦等着，时不时去门口看看外卖送到没，而不能干其他事情。

不过呢，如果在订外卖的时候，你就跟配送员约定好，让他送到后给你打个电话，那你就不用苦苦等待了，就可以去忙别的事情，直到电话一响，接电话、取外卖就可以了。

这里的“打电话”，其实就是一个中断。没接到电话的时候，你可以做其他的事情；只有接到了电话（也就是发生中断），你才要进行另一个动作：取外卖。

**中断其实是一种异步的事件处理机制，可以提高系统的并发处理能力。**

由于中断处理程序会打断其他进程的运行，所以，**为了减少对正常进程运行调度的影响，中断处理程序就需要尽可能快地运行。**

如果中断本身要做的事情不多，那么处理起来也不会有太大问题；但如果中断要处理的事情很多，中断服务程序就有可能要运行很长时间。

中断处理程序在响应中断时，还会临时关闭中断。这就会导致上一次中断处理完成之前，其他中断都不能响应，也就是说中断有可能会丢失。

如果点两份外卖，并且是由 2 个不同的配送员来配送。需要打电话两次，当第一份外卖送到时，配送员给你打了个长长的电话，商量发票的处理方式。

与此同时，第二个配送员也到了，也想给你打电话。很明显电话占线。第二个外卖员电话打不通，配送阻塞。丢失了一次中断。

为了解决中断处理程序执行过长和中断丢失的问题，Linux 将中断处理过程分成了两个阶段，也就是上半部和下半部。

- 上半部用来快速处理中断，它在中断禁止模式下运行，主要处理跟硬件紧密相关的或时间敏感的工作。（硬中断）
- 下半部用来延迟处理上半部未完成的工作，通常以内核线程的方式运行。（软中断）

比如说前面取外卖的例子，上半部就是你接听电话，告诉配送员你已经知道了，其他事儿见面再说，然后电话就可以挂断了；下半部才是取外卖的动作，以及见面后商量发票处理的动作。

这样，第一个配送员不会占用你太多时间，当第二个配送员过来时，照样能正常打通你的电话。

网卡接收到数据包后，会通过**硬件中断**的方式，通知内核有新的数据到了。这时，内核就应该调用中断处理程序来响应它。

- 对上半部来说，既然是快速处理，其实就是要把网卡的数据读到内存中，然后更新一下硬件寄存器的状态（表示数据已经读好了）。最后再发送一个软中断信号，通知下半部做进一步的处理。
- 下半部被软中断信号唤醒后，需要从内存中找到网络数据，再按照网络协议栈，对数据进行逐层解析和处理，直到把它送给应用程序。

实际上，上半部会打断 CPU 正在执行的任务，然后立即执行中断处理程序。而下半部以内核线程的方式执行。

并且每个 CPU 都对应一个软中断内核线程，名字为 “ksoftirqd/CPU 编号”，比如说， 0 号 CPU 对应的软中断内核线程的名字就是 ksoftirqd/0。





# Chrome多进程



传统的浏览器被设计为显示网页，而Chrome的设计目标是支撑“Web App”（当时的js和相关技术已经相当发达了，Gmail等服务也很成功）。

这就要求Chrome提供一个类似于 “[操作系统](https://www.zhihu.com/search?q=操作系统&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A999401453})” 感觉的架构，支持App的运行。而App会变得相当的复杂，这就难以避免出现bug，然后crash。同时浏览器也要面临可能运行“[恶意代码](https://www.zhihu.com/search?q=恶意代码&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A999401453})”。

流览器不能决定上面的js怎么写，会不会以某种形式有意无意的攻击浏览器的渲染引擎。如果将所有这些App和[浏览器](https://www.zhihu.com/search?q=浏览器&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A999401453})实现在一个进程里，一旦挂，就全挂。

现代的Web浏览器提供标签式浏览，它允许开启一个Web浏览器实例，同时打开多个tab来打开多个网站。



因此Chrome一开始就设计为把**隔离性**作为基本的设计原则，用进程的隔离性来实现对App的隔离。这样用户就不用担心：

- 一个Web App挂掉造成其他所有的Web App全部挂掉（稳定性）
- 一个Web App可以以某种形式访问其他App的数据（安全性）

以及Web App之间是并发的，可以提供更好的响应，一个App的渲染卡顿不会影响其他App的渲染（性能）（当然这点线程也能做到）



因此，这样看起来用进程实现非常自然。

Chromium里有三种进程——浏览器、渲染器和插件。

- 浏览器进程只有一个，管理窗口和tab，也处理所有的与磁盘，网络，用户输入和显示的工作。这就是我们看到的“Chrome界面”。
- 渲染器开多个。每个渲染器负责处理HTML、CSS、js、图片等，将其转换成用户可见的数据。以前的 Chrome使用开源的 webkit 实现这个功能。

顺便说一句，webkit是由Apple开发的，当时有很多坑，也被长期吐槽；现在Chrome已经转成使用自家的Blink引擎了。

插件会开很多。每个类型的插件在第一次使用时会启动一个相应的进程。

一般来讲每一个网站的实例都会创建一个渲染进程。但也有特例，比如一个站点通过js在新tab/window上打开同一个站点的另外的页面。这两个界面内部会共享同一个进程，也能彼此分享数据。

在Chrome角度，这两个页面算是“同一个App”。但是如果用户用浏览器的地址栏开一个新的tab，而该网址已经有tab了，Chrome会算是“来自同一域名的两个App”，从而创建新的进程。

但是大家都知道进程开多了资源消耗也变大，因此Chrome会限制最大的进程数量（比如20）。当进程达到这个数量后，Chrome会倾向于去复用已有的进程（所以这时，隔离性就会被影响）。

