# Nginx 介绍





Nginx 是一个高性能的 Web 服务器，从 2001 年发展至今，由于 Nginx 对硬件和操作系统内核特性的深度挖掘，使得在保持高并发的同时还能够保持高吞吐量。

Nginx 还采用了模块设计，有大量的第三方模块可以扩展 Nginx 的功能，因此 Nginx 的场景非常丰富，同时 Nginx 采用的是 BSD 许可证，赋予了 Nginx 最大的灵活性。

简单来说，Nginx 具有以下几个优点：



- 高并发，高性能
- 可扩展性好
- 高可靠，一年之中停机时间可能只有几秒
- 热部署，可以不重启升级
- 灵活性高，采用BSD 许可证



> BSD开源协议是一个给予使用者者很大自由的协议。基本上使用者可以“为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。



截止 2019 年 9 月份，Nginx 的市场份额已经达到了 33%，且还在持续增长，稳居市场头把交椅。



## 诞生背景

Nginx 出现的背景是由于互联网的快速普及导致数据量的快速增长，同时催生出了海量的连接。

传统的 Apache 等服务器采用的是单进程模型，这意味着，每处理一个请求就会创建一个进程，这不但存在进程创建的开销。

而且进程之间相互切换产生的上下文开销也非常耗费 CPU 资源，导致这种传统的服务器在面对成千上万的并发连接时，性能非常低下，而这是快速发展的互联网所不能够忍受的。

在这种背景下，Nginx 采用的是进程池和 epoll 处理模型，这二者加起来使得 Nginx 的性能非常优异，一台 32 核的机器上可以支撑数千万的并发连接。

Nginx 有一个 master 进程和若干个 worker 进程。

master 进程是用来管理 worker 进程的，worker 进程负责处理具体的请求，worker 进程是 master 进程的子进程。

Nginx服务器的一个显著优势是能够同时处理大量并发请求。它结合多进程机制和异步机制对外提供服务，异步机制使用的是异步非阻塞方式

Nginx服务器启动后，可以产生一个主进程（master process）和多个工作进程（worker processes），其中可以在配置文件中指定产生的工作进程数量。

Nginx服务器的所有工作进程都用于接收和处理客户端的请求。这类似于Apache使用的改进的多进程机制，预先生成多个工作进程，等待处理客户端请求。

每个工作进程使用了异步非阻塞方式，可以处理多个客户端请。当某个工作进程接收到客户端的请求以后，调用IO进行处理，如果不能立即得到结果，就去处理其他的请求；

而客户端在此期间业务需等待响应，可以去处理其他的事情；当IO调用返回结果时，就会通知此工作进程；该进程的到通知，暂时挂起当前处理的事务，去响应客户端请求。

客户端请求数量增长、网络负载繁重时，Nginx服务器使用多进程机制能够保证不增长对系统资源的压力；同时使用异步非阻塞方式减少了工作进程在I/O调用上的阻塞延迟，保证了不降低对请求的处理能力。



## Nginx 及其周边

介绍完 Nginx 的背景，我们就该说说 Nginx 的版本了。目前 Nginx 有三个主要的产品：

- 官方 Nginx。包含开源版（nginx.org）和商业版（nginx.com）
- 阿里巴巴的 Tengine。Tengine 是由淘宝网发起的 Web 服务器项目，目前已经开源。
- OpenResty。OpenResty 通过 Lua 对 Nginx 进行扩展，使得扩展 Nginx 模块变得异常轻松

针对我们日常工作学习来说，选择官方开源版的 Nginx 或者 OpenResty 就可以了。





### Nginx 版本策略

------

在 Nginx 中，有两种分支，分别是 mainline 和 stable。

-  Mainline 相当于开发分支，更新比较活跃，包含引入一些新的功能或者bug修复，版本号的第二个数字如果是基数，那就是 Mainline 版本，比如 1.17.0。
- Stable 分支很容易理解，就是相对稳定的版本，除非有重大Bug，否则在它的生命周期内不会更新，版本号的第二个数字如果是偶数，那就是 Mainline 版本，比如 1.16.0。



stable 版本代表功能多少和更新频率，和软件质量没有太大的关系（当然任何软件都会有Bug）。

在每年4月份会发布一次，它的生命周期是一年，在这段时间内，一般情况不会更新版本号（除非有重大Bug）。

https://www.cnblogs.com/91donkey/p/11639355.html





# 安装 Nginx 和 OpenResty

在 Linux 上，当然可以使用 yum、apt-get 等软件包管理工具来下载 Nginx，但是 Nginx 的很多模块并不是默认开启的，第三方模块很多也并不包含。

所以，如果想要开启内置的模块或编译第三方模块，还是需要编译 Nginx。



### 包管理器安装 nginx

------

```shell
# https://www.nginx.com/resources/wiki/start/topics/tutorials/install/

# 配置yum源：/etc/yum.repos.d/nginx.repo 

# CentOS
[nginx]
name=nginx repo
# 系统:CentOS7 架构:x86_64
baseurl=https://nginx.org/packages/centos/7/x86_64/
# 系统:CentOS8 架构:x86_64
# baseurl=https://nginx.org/packages/centos/7/x86_64/
# 系统:RHEL7 架构:x86_64
baseurl=https://nginx.org/packages/rhel/7/x86_64/
# 系统:RHEL8 架构:x86_64
# baseurl=https://nginx.org/packages/rhel/7/x86_64/
gpgcheck=0
enabled=1


```



### 编译安装Nginx

在 <http://nginx.org/en/download.html> 里面可以直接下载 Nginx 源代码。包含以下目录：

```shell
# 安装依赖环境

sudo apt install zlib1g zlib1g-dev

# 在 http://nginx.org/en/download.html 里面下载 Nginx 源代码

wget http://nginx.org/download/nginx-1.16.0.tar.gz
wget http://nginx.org/download/nginx-1.20.1.tar.gz

nginx-1.17.8
├── CHANGES 		# 每个版本提供的特性和 bugfix，changelog文件
├── CHANGES.ru 		# 俄罗斯版本的 CHANGES 文件
├── LICENSE			# 开源许可文件
├── Makefile
├── README
├── auto # 自动检测系统环境以及编译相关的脚本，辅助 config 脚本执行的时候去判定 nginx 支持哪些模块，当前操作系统有什么样的特性可以供给 nginx 使用
├── conf # 示例文件，方便运维配置，会把 conf 示例文件拷贝到安装目录
├── configure # 命令脚本，用来生成中间文件，执行编译前的一个必备动作
├── contrib # 提供了两个 pl 脚本和 vim 工具
├── html # 一个 500 错误的默认页面，另一个是默认的 index 页面
├── man # nginx 对 Linux 的帮助文件，man ./nginx.8
└── src # nginx 源代码



# 配置 Vim 高亮, 如果 Vim 没有开启语法高亮的话，最好开启一下

cp -r contrib/vim/* ~/.vim
echo 'syntax on' > ~/.vimrc 


# configure

./configure   --user=nginx --group=nginx  --prefix=/usr/local/nginx/  --with-http_stub_status_module  --with-http_ssl_module

./configure --help # --help 命令可以查看配置脚本支持哪些参数

# 第一类配置参数

--prefix=PATH                      set installation prefix # 指定这个路径就可以了，其他文件会在 prefix 目录下建立相应的文件夹
--sbin-path=PATH                   set nginx binary pathname
--modules-path=PATH                set modules path
--conf-path=PATH                   set nginx.conf pathname
--error-log-path=PATH              set error log pathname
--pid-path=PATH                    set nginx.pid pathname
--lock-path=PATH                   set nginx.lock pathname


# 第二类配置参数
# 可以配置使用或不使用哪些模块，前缀通常是 with 和 with out，需要加 with 参数的通常是不会被 Nginx 默认编译的，without 则是会移出编译。

--with-http_ssl_module             enable ngx_http_ssl_module
--with-http_v2_module              enable ngx_http_v2_module
--with-http_realip_module          enable ngx_http_realip_module
...

--without-http_charset_module      disable ngx_http_charset_module
--without-http_gzip_module         disable ngx_http_gzip_module
--without-http_ssi_module          disable ngx_http_ssi_module
...


make && make install 




# ubuntu

sudo apt-get install gcc make libpcre3 libpcre3-dev   zlib1g-dev openssl libssl-dev 

```



**配置 Vim**

如果 Vim 没有开启语法高亮的话，最好开启一下

```shell
cp -r contrib/vim/* ~/.vim
# mac 下需要在家目录下新建 .vimrc 文件并配置
syntax on
```



### 编译 Nginx

```shell



./configure --help # --help 命令可以查看配置脚本支持哪些参数


# 第一类配置参数

--prefix=PATH                      set installation prefix # 指定这个路径就可以了，其他文件会在 prefix 目录下建立相应的文件夹
--sbin-path=PATH                   set nginx binary pathname
--modules-path=PATH                set modules path
--conf-path=PATH                   set nginx.conf pathname
--error-log-path=PATH              set error log pathname
--pid-path=PATH                    set nginx.pid pathname
--lock-path=PATH                   set nginx.lock pathname


# 第二类配置参数
# 可以配置使用或不使用哪些模块，前缀通常是 with 和 with out，需要加 with 参数的通常是不会被 Nginx 默认编译的，without 则是会移出编译。

--with-http_ssl_module             enable ngx_http_ssl_module
--with-http_v2_module              enable ngx_http_v2_module
--with-http_realip_module          enable ngx_http_realip_module
...

--without-http_charset_module      disable ngx_http_charset_module
--without-http_gzip_module         disable ngx_http_gzip_module
--without-http_ssi_module          disable ngx_http_ssi_module
...





 1. 使用默认参数，进行 configure 指定编译安装目录
./configure --prefix=/usr/localnginx/
 编译完成后生成 objs 文件夹中间文件
➜   ls -al 
total 176
-rw-r--r--  1 mtdp  staff    40K  3  3 07:23 Makefile
-rw-r--r--  1 mtdp  staff    25K  3  3 07:23 autoconf.err
-rw-r--r--  1 mtdp  staff   5.4K  3  3 07:23 ngx_auto_config.h
-rw-r--r--  1 mtdp  staff   531B  3  3 07:23 ngx_auto_headers.h
-rw-r--r--  1 mtdp  staff   5.7K  3  3 07:23 ngx_modules.c # ngx_modules.c 决定了接下来的编译会生成哪些模块
drwxr-xr-x  9 mtdp  staff   288B  3  3 07:23 src
2. # 编译
make # 生成了大量的中间文件。如果是版本升级，就不能直接 makeinstall，需要将 obj 拷贝到安装目录。如果生成了动态模块，编译后也会放在 objs 目录下
3. # 安装
make install
➜  nginx ll # 安装完成后生成以下文件夹
total 0
drwxr-xr-x  17 mtdp  staff   544B  3  3 07:29 conf # 从 Nginx 源码目录拷贝的
drwxr-xr-x@  4 mtdp  staff   128B  3  3 07:29 html # 从 Nginx 源码目录拷贝的
drwxr-xr-x   2 mtdp  staff    64B  3  3 07:29 logs # 日志文件目录，包括 access log 和 error log
drwxr-xr-x   3 mtdp  staff    96B  3  3 07:29 sbin # Nginx 二进制文件目录
```



### Nginx 安装第三方模块

**安装nginx安装第三方模块**实际上是使用--add-module重新编译**安装**一次**nginx**，

不要 make install 而是直接把编译目录下 objs/**nginx **文件直接覆盖老的 **nginx **文件。如果你需要**安装**多个**nginx第三方模块**,你只需要多指定几个相应的--add-module即可



### 编译 OpenResty

OpenResty 的编译安装步骤与 Nginx 基本一致

在 <https://openresty.org/en/download.html> 中下载 OpenResty 的源代码，然后按照 Nginx 的编译步骤执行即可。







# Nginx 配置文件





```nginx
events {
    worker_connections 1024;
}

http {
    #incloud mime.types;
    #default_type application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log logs/geek.access.log main;
    sendfile on;
    #tcp_nopush on;
    #keepalive_timeout 0;
    keepalive_timeout 65;

    gzip on;
    gzip_min_length 1;
    gzip_comp_level 2;
    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png multipart/form-data;
    server {
        listen 8080;
        server_name 127.0.0.1;
        #charset koi8-r;
        access_log logs/geek.access.log main;
        location /lua {
            default_type text/html;
            content_by_lua '
ngx.say("User-Agent: ", ngx.req.get_headers()["User-Agent"])
';
}
        }
        #error_page 404 /404.html;

    }
```





如上所示，是一个非典型的 Nginx 配置文件，Nginx 的配置文件语法遵循以下规则：

- 配置文件由指令与指令块构成
- 每条指令以 ; 结尾，指令与指令的参数之间以空格符号分割
- 指令块以 {} 将多条指令组织在一起

```
events { # 指令块
    worker_connections 1024; # 指令
}
```

- include 语句允许组合多个配置文件，以提升可维护性
- 使用 # 添加注释
- 使用 $ 符号添加变量
- 部分指令的参数支持正则表达式

## 配置参数

### 时间单位

- ms：毫秒
- s：秒
- m：分钟
- h：小时
- d：天
- M：月 = 30 天
- y：年 = 365 天

### 空间单位

- bytes
- k/K：kilobytes
- m/M：megabytes
- g/G：gigabytes

## HTTP 配置的指令块

- http：表示由 http 模块来处理请求
- upstream：表示上游服务器地址
- server：表示站点地址
- location：表示 URL

这些指令块在接下来都会遇到。







# Nginx 命令行

在刚刚编译完成的 Nginx 目录下，有一个 sbin 目录，就是用来存放 Nginx 的二进制文件的

```
➜  sbin ll
total 1712
-rwxr-xr-x  1 mtdp  staff   854K  3  3 07:29 nginx
```

Nginx 启动时，有一系列的命令行参数可以指定，下面分别介绍一下。

```
./nginx
-h/-? # 打开帮助
-c # 使用指定的配置文件，而不是默认的 conf 文件夹下的配置文件
-g # 指定配置命令，覆盖掉配置文件中的指令
-p # 指定运行目录
-s # 发送信号 stop 立刻停止服务；quit 优雅的停止服务；reload 重载配置文件；reopen 重新开始记录日志文件
-t/-T # 测试配置文件是否有语法错误
-v/-V # 打印 nginx 的版本信息、编译信息等
```



## 热部署

当配置文件发生变更时，需要重载配置文件：

```
nginx -s reload
```



# 升级

但想要更换或者升级 nginx 版本时，就需要采用热部署的方式：

1. 查看现有 master 进程的 pid。可以看出来，worker 进程是 master 进程的子进程





# Nginx 配置指令





nginx.conf 文件是 nginx 中的核心文件，用于控制 nginx 的运行。



一个典型的 nginx 配置文件如下：

```nginx
main

http {
    upstream { … }
    split_clients {…}
    map {…}
    geo {…}
    server {
        if () {…}
        location {
            limit_except {…}
        }
        location {
            location {
            }
        }
    }
    server {
    }
}
```





## 指令块的嵌套



在 Nginx 配置文件中，指令块是可以嵌套分层的，例如上面的示例，http 块中可以包含多个 server 块，server 块中还会包含多个 location 块，每一个块中都有相应的指令。



而每一个指令都有 Context 上下文，也就是生效的环境，这在 Nginx 的官方文档中说的很清楚，例如下面的两条指令，Context 中都表明了各自可以生效的环境，access_log 指令可以在多个上下文中生效：



```nginx
Syntax:  access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];
         access_log off;
Default: access_log logs/access.log combined; 
Context: http, server, location, if in location, limit_except

Syntax:  log_format name [escape=default|json|none] string ...;
Default: log_format combined "..."; 
Context: http
```





## 指令的继承



既然 nginx 指令是可以嵌套分层的，而且指令可以存在于多个上下文环境。所以必然存在指令的继承。



例如下面的配置文件，这里面在 server 块和 location 块中都配置了 root 指令，Nginx 的继承规则如下：

- 子配置不存在时，直接使用父配置块的指令
- 子配置存在时，覆盖父配置块



```nginx
server {
    listen 8080;
    root /home/geek/nginx/html;
    access_log logs/geek.access.log main;
    location /test {
        root /home/geek/nginx/test;
        access_log logs/access.test.log main;
    }
    location /dlib {
        alias dlib/;
    }
    location / {
    }
}    
```



根据上面这两条规则，第一个 location 使用自己的 root 指令，后面两个 location 则使用 server 块的 root 指令。这和编程语言中变量的作用域也是类似的，作用域更小的变量优先级往往更高，Nginx 的指令也是一样。



## 常用 nginx 指令



### listen 指令

listen 指令在 server 块中生效，用来配置监听哪些端口，由这些端口来处理请求。listen 指令的配置语法如下：

```nginx
Syntax:	listen address[:port] [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
listen port [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
listen unix:path [default_server] [ssl] [http2 | spdy] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
Default:	
listen *:80 | *:8000;
# 只能出现在server块中
Context:	server



＃常见的litsen配置语法

listen 443 ssl http2;

listen 127.0.0.1:8080;

listen 8080；

listen *:8080；

listen *:8080；



```





### server_name 指令

server_name 指令是用来配置究竟是哪个 server 来处理我们的请求的。

- server_name 指令后可以跟多个域名，第一个是主域名，多个域名之间空格分隔
- 泛域名：仅支持在最前或最后加 *，例如：`server_name* .taohui.tech`
- 正则表达式匹配：`server_name www.taohui.tech ~^www\d+\.taohui\.tech$;`

```nginx
Syntax  server_name_in_redirect on | off;
Default server_name_in_redirect off; 
Context http, server, location
```





### set 指令





# Nginx热升级



https://blog.csdn.net/gexiaoyizhimei/article/details/101650717

https://www.cnblogs.com/wupeixuan/p/12074007.html





# Nginx 安全配置规范





## 隐藏版本号





# Nginx 反向代理





 `ngx_http_proxy_module` 模块可以使发到 nginx 的请求转发到真正的另外一个后端服务器上。





**反向代理时的头部处理**



在实际应用中，我们可能需要获取用户的 ip 地址，比如做异地登陆的判断，或者统计 ip 访问次数等，通常情况下我们使用 request.getRemoteAddr() 就可以获取到客户端ip。

但是当我们使用了 nginx 作为反向代理后，使用 request.getRemoteAddr() 获取到的就一直是 nginx 服务器的 ip 的地址。

经过反向代理后，由于在客户端和 web 服务器之间增加了中间层，因此web服务器无法直接拿到客户端的 ip，通过 $remote_addr 变量拿到的将是反向代理服务器的ip地址。





