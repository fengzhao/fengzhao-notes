



## 传统本地事务



**事务**是访问并可能更新各种数据项的一个程序执行**单元**(unit)。

事务由一个或多个步骤组成，一般使用形如 `begin transaction` 和 `end transaction` 语句或者函数调用作为事务界限，事务内的所有步骤必须作为一个单一的、不可分割的单元去执行，因此事务的结果只有两种：1. 全部步骤都执行完成，2. 任一步骤执行失败则整个事务回滚。



事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。

也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

事务应该具有 4 个属性：原子性、一致性、隔离性、持久性。这四个属性通常称为 ACID 特性。



**传统的本地事务被称为刚性事务，完全遵循 ACID 规范。**



传统单机应用使用一个RDBMS作为数据源。数据库做为资源管理器。

应用开启事务，进行CRUD，提交或回滚事务，统统发生在本地事务中，由资源管理器（RM）直接提供事务支持。数据的一致性在一个本地事务中得到保证。



![img](分布式事务.assets/20201109184306.png)











## 分布式事务



**分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。**



例如在大型电商系统中，下单接口通常会扣减库存、减去优惠、生成订单 id, 而订单服务与库存、优惠、订单 id 都是不同的服务，下单接口的成功与否，不仅取决于本地的 db 操作，而且依赖第三方系统的结果，这时候分布式事务就保证这些操作要么全部成功，要么全部失败。

> **本质上来说，分布式事务就是为了保证不同数据库实例之间的数据一致性。**



### 问题引出

https://www.cnblogs.com/xybaby/p/7465816.html

https://zhuanlan.zhihu.com/p/71887950



跨行转账是最经典那的分布式事务场景，假设用户 A 使用银行 app 发起一笔跨行转账给用户 B，银行系统首先扣掉用户 A 的钱，然后增加用户 B 账户中的余额。

此时就可能会出现 2 种异常情况：

- 用户 A 的账户扣款成功，用户 B 账户余额增加失败。
- 用户 A 账户扣款失败，用户 B 账户余额增加成功。



由于这两个数据库是不同银行管理的，很显然是分布在不同的银行的不同数据库实例中。

对于银行系统来说，以上 2 种情况都是不允许发生，此时就需要分布式事务来保证转账操作的成功。





在电商系统中，下单是用户最常见操作。在下单接口中必定会涉及生成订单 id，扣减库存等操作。

对于微服务架构的系统，订单 id 与库存服务一般都是独立的服务，一般也是有各自独立的数据库，此时就需要分布式事务来保证整个下单接口的成功。



**在两个不同数据库实例中的事务，是在业务上是原子的，必须同时执行成功或者同时执行失败。**

**这样的事务，就叫分布式事务。**



**如何保证多个事务提交成功呢？**

**显然随着服务的逐步拆分，各个服务均有自己的数据库，这个时候本地事务已经无法满足数据一致性的要求。**

**由于多个数据源的同时访问，事务需要跨多个数据源管理。**





在分布式系统中，每个节点虽然可以知晓自己的操作时成功或者失败，却无法知道其他节点的操作的成功或失败。

当一个事务跨越多个节点时，为了保持事务的ACID特性，需要引入一个作为协调者的组件来统一掌控所有节点（称作参与者）的操作结果并最终指示这些节点是否要把操作结果进行真正的提交。



在电商领域等互联网场景下，传统的事务在数据库性能和处理能力上都遇到了瓶颈。

因此，柔性事务被提了出来，柔性事务基于分布式 `CAP` 理论以及延伸出来的 `BASE` 理论。

相较于数据库事务这一类完全遵循 `ACID` 的刚性事务来说，柔性事务保证的是 “基本可用，最终一致”，`CAP` 原理相信大家都很熟悉了。

这里我们讲一下 `BASE` 原则：

- **基本可用（Basically Available）：系统能够基本运行、一直提供服务。**
- **软状态（Soft-state）：系统不要求一直保持强一致状态。**
- **最终一致性（Eventual consistency）：系统需要在某一时刻后达到一致性要求。**



柔性事务（如分布式事务）为了满足可用性、性能与降级服务的需要，降低了一致性（Consistency）与隔离性（Isolation）的要求。

遵循 `BASE` 理论，传统的 `ACID` 事务对隔离性的要求非常高，在事务执行过程中，必须将所有的资源对象锁定，因此对并发事务的执行极度不友好。

柔性事务（比如分布式事务）的理念则是将锁资源对象操作从本地资源对象层面上移至业务逻辑层面，再通过放宽对强一致性要求，以换取系统吞吐量的提升。









## 数据一致性

一致性：分布式环境下多个节点的数据是否强一致。

### 强一致性

任何一次读都能读到某个数据的最近一次写的数据。

系统中的所有进程，看到的操作顺序，都和全局时钟下的顺序一致。简言之，在任意时刻，所有节点中的数据是一样的。

### 弱一致性

数据更新成功后，系统不承诺立即可以读到最新写入的值，也不承诺具体多久之后可以读到。



### 最终一致性

弱一致性的一种形式，数据更新成功后，系统不承诺立即可以返回最新写入的值，但是保证最终会返回上一次更新操作的值。

不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化。

简单说，就是在一段时间后，节点间的数据会最终达到一致状态。







## CAP 原则



CAP 原则又称 CAP 定理，指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。



#### 一致性（C）

在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）



#### 可用性（A）

在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）



#### 分区容错性（P）

以实际效果而言，分区相当于对通信的时限要求。

系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在 C 和 A 之间做出选择。



CAP 原则的精髓就是要么 AP，要么 CP，要么 AC，但是不存在 CAP。

如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况。此时 C 和 P 两要素具备。

但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问。

此时可用性条件就不能被满足，即在此情况下获得了 CP 系统，但是 CAP 不可同时满足。





## 分布式事务的问题



对于分布式事务来说，有两个最核心的问题：

- 如何管理分布式事务的提交/放弃决定？如果事务中的一个节点在执行自己的本地事务过程中遇到错误，希望放弃整个分布式事务，与此同时其他节点则在事务执行过程中一切顺利，希望提交这个分布式事务，此时我们应该如何做决策

- 如何保证并发事务在涉及多个节点上资源对象访问的可串行性（规避分布式死锁）？如果事务 T 对某一个服务器节点上的资源对象 S 的并发访问在事务 U 之前，那么我们需要保证在所有服务器节点上对 S 和其他资源对象的冲突访问，T 始终在 U 之前。







## 两阶段提交

https://qiuyadongsite.github.io/2019/03/04/framework4-highConcurrent-10/

**XA 是由X/Open组织提出的分布式事务的规范。** 



XA规范主要定义了 **(全局)事务管理器(TM)和(局部)资源管理器(RM) 之间的接口。主流的关系型 数据库产品都是实现了XA接口的**。

- 事务管理器（transaction manager）：

  - 事务管理器是分布式事务的核心管理者。事务管理器与每个资源管理器（resource manager）进行通信，协调并完成事务的处理。
  - 即分布式事务，都是由管理器来管理的。
  - 事务的各个分支由唯一命名进行标识

- 资源管理器（resource manager）：

  - 用来管理系统资源，是通向事务资源的途径。
  - 数据库就是一种资源管理器。资源管理还应该具有管理事务提交或回滚的能力。





  Xid 接口 Xid, Xid 接口是 X/Open 事务标识符 XID 结构的 Java 映射。

  此接口指定三个访问器方法，以检索全局事务格式 ID、全局事务 ID 和分支限定符。Xid 接口供事务管理器和资源管理器使用。此接口对应用程序不可见。
  XA 不能自动提交。

通俗点说，在 MySQL 分库分表的架构中。**事务管理器就相当于数据库中间件：mycat，shardingsphere，**

**资源管理器就相当于多个不同机器上的数据库节点。**



![](分布式事务.assets/20201109185605.png)











在XA协议中的事务提交分为两阶段:

- 第一阶段（prepare）：事务管理器要求每个涉及到事务的数据库预提交 (precommit) 此操作，并反映是否可以提交。（投票）
  - 即所有的参与者准备执行事务并锁住需要的资源。参与者ready时，向transaction manager报告已准备就绪。
- 第二阶段（commit/rollback）：事务协调器要求每个数据库提交数据，或者回滚数据。
  - 当transaction manager确认所有参与者都ready后，向所有参与者发送commit命令。



优点： 尽量保证了数据的强一致，实现成本较低，在各大主流数据库都有自己实现，对于MySQL是从5.5开始支持XA事务。



### 两阶段存在的问题



> 单点故障：一旦事务管理器出现故障，整个系统不可用
>
> 
>
> 数据不一致：
>
> 在阶段二，如果事务管理器只发送了部分 commit 消息，此时网络发生异常或者部分节点故障，那么只有部分参与者接收到 commit 消息，也就是说只有部分参与者提交了事务，当网络恢复时还是会存在系统数据不一致。
>
> 第二个是挂了之后又恢复了，这时如果他有未执行完的事务操作，直接取消掉，然后询问协调者目前我应该怎么做，协调者就会比对自己的事务执行记录和该参与者的事务执行记录，告诉他应该怎么做来保持数据的一致性。
>
> 
>
> 不确定性：当事务管理器发送 commit 之后，并且此时只有一个参与者收到了 commit，那么当该参与者与事务管理器同时宕机之后，重新选举的事务管理器无法确定该条消息是否提交成功。
>
> 
>
> 

















### BASE 理论

eBay 的架构师Dan Pritchett，曾在一篇解释BASE 原理的论文《[Base：An Acid Alternative](https://queue.acm.org/detail.cfm?id=1394128)》中提到一个eBay 分布式系统一致性问题的解决方案。

它的核心思想是将需要分布式处理的任务通过消息或者日志的方式来异步执行，消息或日志可以存到本地文件、数据库或消息队列，再通过业务规则进行失败重试，它要求各服务的接口是幂等的。





















参考 



https://xiaomi-info.github.io/2020/01/02/distributed-transaction/

https://jeremyxu2010.github.io/2020/03/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%96%B9%E6%A1%88/#heading-7	

https://www.cnblogs.com/luxiaoxun/p/8832915.html