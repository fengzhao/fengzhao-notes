



# 楔子

在云计算时代，虚拟机和容器已经成为标配。它们背后的网络管理都离不开一样东西，就是虚拟网络设备，或者叫虚拟网卡，tap/tun 就是在云计算时代非常重要的虚拟网络网卡。





## Linux网络接口

`eth0`, `eth8`, `radio0`, `wlan19`，这些符号总是代表着真实存在的网络设备。 例如： **NIC（有线网卡）**, **WNIC（无线网卡）**

当[device driver](https://en.wikipedia.org/wiki/device driver)被作为物理网络接口的驱动加载进内核，这些网络接口就可用了。

任何物理网络接口是由操作系统为用户命名的软件的网络接口，以使得操作系统配置物理网络设备并且将其集成到程序和脚本中。普通的物理网络接口如 eth0，它的两端分别是内核协议栈和外面的物理网络。



## **虚拟网络接口**

```
lo`, `eth0:1`, `eth0.1`, `vlan2`, `br0`, `pppoe-dsl`, `gre0`, `sit0` `tun0`, `imq0`, `teql0`, `docker0
```

这些都是不真实存在物理网络设备的虚拟的网络接口，但是 linked（不知道如何翻译）到一个物理设备（否则他们是没有价值的）。

**发明虚拟网络接口是为了给予系统管理员配置基于Linux的操作系统的最大的灵活性。一个虚拟的网络接口是一般联合一个物理网络接口（eth）或其他的虚拟网络接口（eth6.9）或是独立的。**



**VLAN**

在Linux中，VLAN子接口允许您在一个物理网络接口上创建多个逻辑接口，以便处理不同的VLAN流量。

VLAN 用来将单独的第二层网络(数据链路层)分割成多个虚拟的。所有参与的网卡都必须支持[IEEE 802.1Q](https://en.wikipedia.org/wiki/IEEE 802.1Q)，并又相应正确的配置。

在RHEL7中，默认载入 `8021q` 模块。比如在某些场景中，我们希望在Linux服务器(CentOS/RHEL)上的同一网卡分配来自不同VLAN的多个ip

```bash
# 在以太网接口 enp1s0 上创建一个 802.1Q VLAN 接口，名称为 VLAN8 ， VLANID为8 , 将 VLAN ID 解释为十六进制值
ip link add link enp1s0 name enp1s0.8 type vlan id 8
```

对于 TUN/TAP 虚拟接口如 tun0，它的一端一定是连接的用户层程序，另一端则视配置方式的不同而 变化，可以直连内核协议栈，也可以是某个 bridge



## 物理网卡

**网络适配器**又称**网卡**或**网络接口卡**(NIC，***Network Interface Card***)。

它是使计算机联网的设备，平常所说的网卡就是将PC机和LAN连接的网络适配器。网卡通常是插在计算机主板插槽中，负责将用户要传递的数据转换为网络上其它设备能够识别的格式。

通过网络介质传输数据在计算机总线中传输是并行方式，即数据是肩并肩传输的，而在网络的物理缆线中说数据以串行的比特流方式传输的，网卡承担串行数据和并行数据间的转换，同时也承担数字信号到模拟信号的转换。

网卡在发送数据前要同接收网卡进行对话以确定最大可发送数据的大小，发送的数据量的大小，两次发送数据间的间隔，等待确认的时间，每个网卡在溢出前所能承受的最大数据量，数据传输的速度。

每个网卡都有一个由硬件制造商分配的唯一标识号，称为 **MAC地址，**有时也称为物理地址。MAC 用于识别网络上的特定设备，并可用于自动执行网络连接上的验证过程。

也许您曾经使用过路由器的MAC地址过滤功能，插入此地址可以让这些计算机连接或不连接到网络。白名单上的人是可以连接到网络和互联网的人，而黑名单上的人是不能连接到网络和互联网的人。

对于互联网设备，常见的物理网卡：

- 无线网卡（笔记本电脑，手机等中内置无线网卡）

- 台式PC主板板载网卡（类似集成显卡集成在CPU上一样，网卡也可以集成在主板上，可以有线可以无线）

  **板载网卡：**台式电脑的特点是它比内部电脑占用更少的空间，并且不需要安装，因为它已经集成到主板本身中。

- **PCIE等外置千兆网卡（像独立显卡一样在主板上可插拔）/ USB网卡**

物理网卡是一个硬件设备，硬件设备要在操作系统上工作，需要有对应的驱动程序。物理网卡的驱动程序向操作系统内核注册该网卡设备，从而让内核识别该物理网卡。

所以以前安装win7时，都需要额外单独安装网卡驱动显卡驱动等。现在的win10等，操作系统中内置了集成了大部分硬件驱动，装完系统后一般都不需要自己再单独安装驱动。

网卡注册成功后，用户就可以在操作系统中看到该物理网卡对应的网卡接口(如Linux中的eth0、Windows中本地连接等名称)，经过一番配置，就可以启动该网卡设备使其工作。

但是需要注意，**网卡注册成功后，并非一定会显示对应的接口名称，这取决于设备管理程序的行为。换句话说，即使看不到网卡接口，但可能它对应的网卡设备已经可以工作。**

普通的物理网络接口如 eth0，它的两端分别是内核协议栈和外面的物理网络。



**物理网卡**

物理网卡这里指的是服务器上实际的网络接口设备。比如有的物理服务器，物理上有双网卡或多个网卡，可以接多根网线。

物理网卡是《硬件设备》，硬件设备要在操作系统上工作，需要有对应的驱动程序。物理网卡的驱动程序向操作系统内核注册该网卡设备，从而让内核识别该物理网卡。

网卡注册成功后，用户就可以看到该物理网卡对应的网卡接口(如eth0、本地连接等名称)，再经过一番配置，就可以启动该网卡设备使其工作。

比如服务器的双网卡，在系统中看到的2个物理网卡分别对应是eth0和eth1这两个网络接口。可以针对网卡接口做一些配置，比如配置IP地址、配置DNS、配置是否使用DHCP动态获取IP地址等等。

看起来这些属性都是配置在网卡上的，之所以会这样认为大概是因为这些属性都是直接控制对应网卡的。

其实这些属性都配置在内核中，严格来说一部分信息保存在内核的网络协议栈中。

更严格地说，这些属性都应该称之为网卡接口的属性，而不是网卡属性，所谓的网卡属性是那些网卡出厂设置的硬件属性，比如MAC地址。



**网卡命名规范**

Centos 6及之前的版本网卡命名格式：eth[0123…]

Centos 7为了方便定位和区分网络设备，采用一致网络设备命名（CONSISTENT NETWORK DEVICE NAMING）规范，支持 biosdevname 和 net.ifnames 两种命名规范。



**子网卡**

子网卡在这里并不是实际上的网络接口设备，但是可以作为网络接口在系统中出现，如eth0:1、eth1:2这种网络接口。

它们必须要依赖于物理网卡，虽然可以与物理网卡的网络接口同时在系统中存在并使用不同的IP地址，而且也拥有它们自己的网络接口配置文件。

但是当所依赖的物理网卡不启用时（Down状态）这些子网卡也将一同不能工作。这就相当于一个网卡





## 虚拟网卡

在Linux网络中，TUN与TAP是操作系统内核中的虚拟网络设备。tap/tun 是 Linux Kernel 2.4.x 版本之后实现的虚拟网络设备。

不同于物理网卡靠硬件网路板卡实现的设备。tap/tun 虚拟网卡完全由软件来实现，功能和硬件实现完全没有差别，等同于网络设备，都可以配置 IP，都归 Linux 网络设备管理模块统一管理。

作为网络设备，它操作第二层数据包如以太网数据帧。tap/tun 也需要配套相应的驱动程序才能工作。tap/tun 驱动程序包括两个部分，一个是字符设备驱动，一个是网卡驱动。



tap/tun 是Linux内核 2.4.x 版本之后使用软件实现的虚拟网络设备，这类接口仅能工作在内核中。不同于普通的网络接口，没有物理硬件(因此也没有物理线路连接到这类接口)。

可以将tun/tap接口认为是一个普通的网络接口，当内核决定发送数据时，会将数据发送到连接到该接口上的用户空间的应用(而不是"线路"上)。

当一个程序附加到tun/tap接口上时，该程序将获得一个特定的文件描述符，从该描述符上可以获得接口上发送过来的数据。

类似地，程序也可以往该描述符上发送数据(需要保证数据格式的正确性)，然后这些数据会输入给tun/tap接口，内核中的tun/tap接口就像从线路上接收到数据一样。





这两部分驱动程序分工不太一样: 

- **字符驱动**负责数据包在内核空间和用户空间的传送。写入字符设备`/dev/net/tun`的数据会发送到虚拟网络接口中；
- **网卡驱动**负责数据包在 TCP/IP 网络协议栈上的传输和处理。发送到虚拟网络接口中的数据也会出现在该字符设备上。



在云原生虚拟网络中， flannel 的 UDP 模式中的 `flannel0` 就是一个 tun 设备，`OpenVPN` 也利用到了 tun/tap 进行数据的转发。

应用程序可以通过标准的`Socket API`向TUN/TAP接口发送IP数据包，就好像对一个真实的网卡进行操作一样。



不同于普通靠硬件网路板卡实现的设备，这些虚拟的网络设备全部用软件实现，并向运行于操作系统上的软件提供与硬件的网络设备完全相同的功能。



**TAP等同于一个以太网设备，TUN模拟了网络层设备，操作第三层数据包比如IP数据封包。**

操作系统通过TUN/TAP设备向绑定该设备的用户空间的程序发送数据，反之，用户空间的程序也可以像操作硬件网络设备那样，通过TUN/TAP设备发送数据。

在后种情况下，TUN/TAP设备向操作系统的网络栈投递（或“注入”）数据包，从而模拟从外部接受数据的过程。







## veth

veth 是另一种主流的虚拟网卡方案，在 Linux Kernel 2.6 版本，Linux 开始支持网络名空间隔离的同时。也提供了专门的虚拟以太网（Virtual Ethernet，习惯简写做 veth）让两个隔离的网络名称空间之间可以互相通信。

veth 实际上不是一个设备，而是一对设备，因而也常被称作 Veth-Pair。Docker 中的 Bridge 模式就是依靠 `veth-pair` 连接到 `docker0` 网桥上与宿主机乃至外界的其他机器通信的。



![image](https://img2022.cnblogs.com/blog/2918913/202208/2918913-20220810100138054-180398644.jpg)





## 虚拟机交换机/网桥

在现实物理网络环境中，多台不同的物理机之间是如何连接一起互相通信的呢？ 没错，那就是以太网交换机。同一网络内的多台物理机通过交换机连在一起，然后它们就可以相互通信了。



有了虚拟网卡，我们很自然就会联想到让网卡接入到交换机里，来实现多个容器间的相互连接。

而Linux Bridge就是 Linux 系统下的虚拟化交换机，虽然它是以“网桥”（Bridge）而不是“交换机”（Switch）为名，但在使用过程中，你会发现 Linux Bridge 看起来像交换机，功能使用起来像交换机、程序实现起来也像交换机，所以它实际就是一台虚拟交换机。

在网络虚拟化环境里，和物理网络中的交换机一样，也需要这样的一个软件实现的设备。它需要有很多个虚拟端口，能把更多的虚拟网卡连接在一起，通过自己的转发功能让这些虚拟网卡之间可以通信。 



Linux Bridge 是在 Linux Kernel 2.2 版本开始提供的二层转发工具，由brctl命令创建和管理。

Linux Bridge 创建以后，就能够接入任何位于二层的网络设备，无论是真实的物理设备（比如 eth0），还是虚拟的设备（比如 veth 或者 tap），都能与 Linux Bridge 配合工作。



当有二层数据包（以太帧）从网卡进入 `Linux Bridge`，它就会根据数据包的类型和目标 MAC 地址，按照如下规则转发处理：

- 如果数据包是广播帧，转发给所有接入网桥的设备。如果数据包是单播帧，且 MAC 地址在地址转发表中不存在，则洪泛（Flooding）给所有接入网桥的设备，并把响应设备的接口与 MAC 地址学习（MAC Learning）到自己的 MAC 地址转发表中。

- 如果数据包是单播帧，且 MAC 地址在地址转发表中已存在，则直接转发到地址表中指定的设备。

- 如果数据包是此前转发过的，又重新发回到此 Bridge，说明冗余链路产生了环路。由于以太帧不像 IP 报文那样有 TTL 来约束，所以一旦出现环路，如果没有额外措施来处理的话，就会永不停歇地转发下去。

  那么对于这种数据包，就需要交换机实现生成树协议（Spanning Tree Protocol，STP）来交换拓扑信息，生成唯一拓扑链路以切断环路。



刚刚提到的这些名词，比如二层转发、泛洪、STP、MAC 学习、地址转发表，等等，都是物理交换机中已经非常成熟的概念了，它们在 Linux Bridge 中都有对应的实现，所以我才说，Linux Bridge 不仅用起来像交换机，实现起来也像交换机。

不过，它与普通的物理交换机也还是有一点差别的，**普通交换机只会单纯地做二层转发，Linux Bridge 却还支持把发给它自身的数据包，接入到主机的三层协议栈中**。



在 Linux 下这个软件实现交换机的技术就叫做 bridge（再强调下，这是纯软件实现的）。

同 `tap/tun`、`veth-pair` 一样，Bridge 也是一种虚拟网络设备，所以具备虚拟网络设备的所有特性，比如可以配置 IP、MAC 等。除此之外，Bridge 还是一个交换机，具有交换机所有的功能。



`Linux Bridge` 与普通交换机的区别是，除了显式接入的设备外，它自己也无可分割地连接着一台有着完整网络协议栈的 Linux 主机。

因为 Linux Bridge 本身肯定是在某台 Linux 主机上创建的，我们可以看作是 Linux Bridge 有一个与自己名字相同的隐藏端口，隐式地连接了创建它的那台 Linux 主机。

因此，Linux Bridge 允许给自己设置 IP 地址，这样就比普通交换机多出了一种特殊的转发情况：

**如果数据包的目的 MAC 地址为网桥本身，并且网桥设置了 IP 地址的话，那该数据包就会被认为是收到发往创建网桥那台主机的数据包，这个数据包将不会转发到任何设备，而是直接交给上层（三层）协议栈去处理。**

这时，网桥就取代了物理网卡 eth0 设备来对接协议栈，进行三层协议的处理。





在安装Docker默认环境中，一个名为``的 `Linux bridge`自动被创建好了，其上有一个 `docker0` 内部接口，IP地址为172.17.0.1/16

用 `docker network inspect bridge`指令查看 这个`bridge`网络：其Gateway就是网卡/接口docker0的IP地址：172.17.0.1。

每次创建一个新容器的时候，Docker 从可用的地址段中选择一个空闲的 IP 地址分配给容器的 `eth0` 端口。使用本地主机上 `docker0` 接口的 IP 作为所有容器的默认网关。

https://www.cnblogs.com/wsg1100/p/18662571



```bash
# 创建网桥br0
sudo ip link add name br0 type bridge


# 启动网桥
sudo ip link set dev br0 up

# 并配置网桥IP
sudo ip addr add 172.10.1.10/24 dev br0

# 查看创建的网桥
sudo ip link show  br0

# 物理接口（如 eth0）添加到网桥之前，通常需要先将该物理接口的 IP 地址配置移除（如果它有的话），并将其状态设置为 UP 但不分配 IP 地址（ip link set dev eth0 up）。
# 一旦它成为网桥的从属，其IP地址将由网桥接口 br0 接管。


```





## 用户空间与内核空间的数据传输



在 Linux 中，用户空间和内核空间的数据传输有多种方式，字符设备就是其中的一种。

tap/tun 通过驱动程序和一个与之关联的字符设备，来实现用户空间和内核空间的通信接口。