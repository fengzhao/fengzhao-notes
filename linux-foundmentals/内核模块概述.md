# 概述

理解操作系统工作原理最好的方法是抽象思维，换句话说，你可以暂时忽略大部分细节。

就像坐车一样，通常你不会去在意车内固定发动机的装配螺栓，也不会关心你走的路是谁修筑的。

如果你是一个乘客的话，你可能只关心车要做的事情（比如车要把你带到哪）以及车的一些基本操作（比如如何打开车门、怎样系好安全带）。

如果你在开车的话，就需要了解更多的细节，比如如何控制油门、怎样换挡，还有如何处理意外情况。

如果我们觉得开车这个事情太复杂，就可以运用“抽象思维”来帮助理解。首先你可以将“一辆汽车在路上行驶”抽象为三个部分：汽车、道路和驾驶操作。

这样有助于将复杂的问题分解开来。如果道路颠簸，你不会去埋怨车辆本身和你的驾驶技术。

相反，你可能会问为什么这条路这么烂，或者如果这是条新修的路的话，那么筑路工人的活干得可真够差劲的。

软件开发人员运用抽象思维来开发操作系统和应用程序。在计算机软件领域有许多术语来描述抽象的子系统，如子系统、模块和包等。本书中我们使用组件这个相对简单的词。在软件开发过程中，开发人员通常不用太关心他们需要使用的组件的内部结构，他们只关心能使用哪些组件，以及怎么个用法。



# 内核概述



**操作系统**

广义上的操作系统，就是整个计算机硬件上层的所有软件，可以分为两部分：操作系统的



**操作系统的核心——内核**

内核就是狭义上的操作系统，主要是用来管理和分配计算机资源（CPU，RAM，和其他设备）。

对于Linux系统，**一般会将内核的可执行文件命名为 /boot/vmlinuz-4.15.0-52-generic 类似的路径，后面的数字表示内核版本号。**

内核及其参数（通常是）在root文件系统中。因为内核此时还没有开始运行，无法遍历文件系统，所以内核参数需要被放到一个容易存取的地方。

并且此时用于访问磁盘的内核设备驱动还没有准备好，这听起来有点像“鸡生蛋，蛋生鸡”。

在个人电脑上，引导装载程序使用基本输入输出系统（以下简称 BIOS）或者统一可扩展固件接口（Unified Extensible Firmware Interface，以下简称UEFI）来访问 磁盘。

几乎所有的磁盘设备都有固件系统供BIOS通过线性块寻址（Linear Block Addressing）来 访问硬件。虽然性能不怎么样，但是这种方式可以访问磁盘的任意位置。

引导装载程序往往是唯 一使用BIOS访问磁盘的程序。内核使用的是它自己的高性能驱动程序。

大多数现在的引导装载程序都能够读取分区表，内建以只读模式访问文件系统的功能，因此 它们能够查找和读取文件。这使得动态配置和完善引导装载程序变得非常简单。

并不是所有的 Linux引导装载程序都有这些功能，配置引导装载程序因而变得困难得多。

GRUB意指大一统引导装载程序（Grand Unified Boot Loader）。 GRUB有一个较老的版本叫作GRUB Legacy，现在逐渐被淘汰了。

Centos 7 默认使用GRUB2引导系统启动,GRUB2 是基于 GRUB 开发成更加安全强大的多系统引导程序，最新Linux发行版都是使用GRUB2作为引导程序。

同时GRUB2采用了模块化设计，使得GRUB2核心更加精炼，使用更加灵活，同时也就不需要像GRUB分为 stage 1、stage 1.5、stage 2三个阶段。



GRUB最重要的一个功能是对内核映像和配置的选择更为简便。我们可以通过查看菜单来了 解GRUB。GRUB界面易于操作，不过Linux的发行版尽可能将引导装载程序隐藏起来，你可能没 机会看到。

在开机时，BIOS或者固件启动屏幕出现时按住SHIFT来打开GRUB菜单。按E键查看引导装载程序命令的默认启动选项。

root文件系统被设置为一个UUID，内核映像是/boot/vmlinuz-5.4.0-28-generic ，内核参数包括 ro 、 quiet 和 splash 。初始RAM文件系统是 /boot/initrd.img-3.2.0- 31-generic-pae 。

(1) BIOS或者固件初始化硬件，在启动存储设备上寻找启动代码。

(2) BIOS和固件运行找到的启动代码，开始GRUB。

(3) 加载GRUB核心。

(4) 初始化GRUB核心，此时GRUB可以读取磁盘和文件系统。

(5) GRUB识别启动分区，在那里加载配置信息。

(6) GRUB为用户提供一个更改配置的机会。

(7) 超时或者用户完成操作以后，GRUB执行配置（执行顺序在5.5.2节有介绍）。

(8) 执行过程当中，GRUB可能会在启动分区中加载额外的代码（模块）。

(9) GRUB执行 boot 命令，以加载和执行配置信息中 linux 命令指定的内核。

GRUB有自己的设备寻址方式。例如，系统检测到的第一个硬盘是hd0，然后 是hd1，以此类推。然而设备分配会有变化。还好GRUB能够在所有的分区中通过UUID来查找得 内核所在的分区。

​                root@racknerd-79c7a3:~# cat /proc/cmdline BOOT_IMAGE=/boot/vmlinuz-5.4.0-28-generic root=UUID=9de45e18-29e7-4330-b5ab-8a272f87aa36 ro net.ifnames=0 biosdevname=0 netcfg/do_not_use_netplan=true root@racknerd-79c7a3:~#               

这些参数有的是一个单词的长度，诸如 ro 、 quiet ，有的是 key=value 这样的配对（例如 vt.handoff=7 ）。

Linux 内核版本命名在不同的时期有其不同的规范，我们熟悉的也许是 2.x 版本奇数表示开发版、偶数表示稳定版，但到 2.6.x 以及 3.x 甚至将来的 4.x ，内核版本命名都不遵守这样的约定。

在 Linux 内核官网上你会看到主要有四种类型的内核版本

- **mainline** 是主线版本，目前主线版本为 6.2
- **stable** 是稳定版，由 mainline 在时机成熟时发布，稳定版也会在相应版本号的主线上提供 bug 修复和安全补丁，但内核社区人力有限，因此较老版本会停止维护，而标记为 **EOL** (End of Life)的版本表示不再支持的版本。
- **longterm** 是长期支持版，目前还处在长期支持版的有五个版本的内核，分别为 3.10、3.4、3.2、2.6.34、2.6.32，长期支持版的内核等到不再支持时，也会标记**EOL**。



# 内核模块概述

> 内核模块是一段可以动态加载进内核的代码

Linux 内核模块的确切定义是，能够根据需要在内核中动态加载和卸载的代码段。这些模块可以增强内核功能，而无需重启系统。





**设备驱动模块**就是一个明显的例子，它有助于内核与连接到系统的硬件组件进行交互。

在没有模块的情况下，主流方法倾向于单片内核，要求将新功能直接集成到内核映像中。这种方法会导致内核变大，当需要新功能时，就必须重建内核并随后重启系统。





我们常见的文件系统、驱动程序等都可以通过模块的方式添加到内核而无需对内核重新编译，这在很大程度上减少了操作的复杂度。模块机制使内核预编译时不必包含很多无关功能，把内核做到最精简，后期可以根据需要进行添加。而针对驱动程序，因为涉及到具体的硬件，很难使通用的，且其中可能包含了各个厂商的私密接口，厂商几乎不会允许开发者把源代码公开，这就和linux的许可相悖，模块机制很好的解决了这个冲突，允许驱动程序后期进行添加而不合并到内核。



Linux 发行版在软件包中提供了 `modprobe `、 `insmod `和 `depmod `命令。

```bash
# Ubuntu/Debian GNU/Linux
$ sudo apt-get install build-essential kmod
```

要了解当前内核中已经加载了哪些模块，请使用 `lsmod `命令。

```
lsmod
```





模块存储在 /proc/modules 文件中，因此也可以用以下命令查看它们：







在深入研究代码之前，需要注意一些事项。每个人的系统都存在差异，个人的方法也各不相同。要成功编译和加载 "hello world "程序，有时可能会遇到困难。

令人欣慰的是，第一次尝试就克服了最初的障碍，为以后的工作顺利进行铺平了道路。