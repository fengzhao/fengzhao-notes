# Android 概述

Android，常见的非官方中文名称为安卓，由谷歌(Google)公司发布的一个基于 Linux 内核的开放源代码移动操作系统。Android 最初由 Andy · Rubin 等人开发制作，最初目的是创建一个数码相机的先进操作系统，于2005年7月11日被 Google 收购。

2007年11月，Google 与 84 家硬件制造商、软件开发商及电信营运商成立开放手持设备联盟来共同研发改良 Android，随后Google 以 Apache 免费开放源代码许可证的授权方式。第一部 Android 智能手机发布于2008年9月22日。

Android是一个多义词，它即可用与指代由谷歌联合84家OEM厂商、芯片制造商、软件开发商与电信运营商组建的开放手机联盟OHA(Open Handset Alliance)打造，通过Apache许可证免费开源的移动操作系统，也可以代表谷歌所拥有的Android商标。

Android 底层使用开源的 Linux 操作系统，亦可归于嵌入式系统，同时开放了应用程序开发工具，使用 Java 语言进行开发(也支持 Kotlin)，所有程序开发人员都在统一、开放的开发平台上进行开发，保证了 Android 应用程序的可移植性。



AOSP是"Android Open-Source Project"的缩写，中文名称为Android 开放源代码项目。

Android 开放系统平台 (AOSP) 是公开发布且可修改的 Android 源代码。任何人都可以下载并修改其设备的 AOSP。AOSP 提供 Android 移动平台的完整且功能完备的实现。

AOSP通用内核 （[AOSP common kernels](https://android.googlesource.com/kernel/common/)，也称为 Android 通用内核或 **ACK**）是 [kernel.org](https://www.kernel.org/) 内核的下游，包含与 Android 社区相关但尚未合并到Linux主线内核或长期支持 (LTS) 内核的补丁程序。

`android-mainline` 是 Android 功能的主要开发分支。每当 Linus Torvalds 发布内核版本或候选内核版本时，Linux 主线内核就会合并到 `android-mainline` 中。

在 2019 年之前，Android 通用内核是通过克隆最新声明的 LTS 内核并添加 Android 专用补丁程序来构建的。

2019 年，这一过程变为从 `android-mainline` 中分支出新的 Android 通用内核。



大家都知道Android 是开源操作系统，所以Google 发布一个Android版本，都会给开源社区发放对应版本的源代码，也就是我们所说的AOSP ROM，这可以称得上是最为纯净的Android 系统。



通常，原生Android系统就等于AOSP+谷歌移动服务（GMS）。而AOSP中也包含了开发者构建Android所需的一切，但它并不包括智能手机所需要的一切。



从理论上来将，根据Apache许可证的条件，任何人都能基于AOSP定制属于自己的Android系统。

但这个系统在未经谷歌允许的情况下不可以使用Android商标，而大家所使用的大多数安卓手机在启动时显示的“Powered by Android”，其实就是获得谷歌许可的标志。



此外AOSP也不包含谷歌的软件应用套件，例如Chrome浏览器、YouTube，甚至Google Play商店。

也不包括谷歌的一些底层技术和API，而这些技术和API则可以实现移动支付、语音命令和云存储等功能，但它们都是作为GMS单独授权的，并且这一授权是收费的。

换而言之，谷歌免费提供给外界的AOSP负责给Android扬名，GMS则负责依靠Android的市场份额挣钱。



最为重要的是，AOSP即代表着官方原生，因为相对纯净无修改，在系统稳定性和流畅性表现都中规中矩，系统体验方面也向Nexus系列亲儿子看齐。多数民间ROM制作者没有办法获得Sense、Touwiz 等UI界面的源代码，几乎所有的AOSP ROM，看上去都是原生Android 的样子，所以刷了AOSP ROM，即意味着放弃厂商那套个性的UI外衣，亦或者是许多你难以割舍的小细节。不过，Android 系统发展到现在，界面上已经不能用简陋来评价它，功能方面需要第三方软件弥补的空间也越来越小，比如我在Android 2.3 时代，很难接受原生UI那套解锁和通话界面，总会额外装一个美化功能的第三方解锁软件，在升级到Android 4.0 后，原生的界面已经足够漂亮，我不会想换其他美化软件替换。







# ADB概述



Google 将 adb 包含在了 Android SDK 平台工具软件包当中，使用 Android Studio 的开发者可以通过内建的 [SDK 管理器](https://developer.android.google.cn/studio/intro/update#sdk-manager) 直接下载或更新包含 adb 工具的平台工具软件包（Platform-Tools）。

对一般用户而言，如非技能学习需要，则完全没必要下载体积动辄 600~700M 的 Android Studio 安装包——Google 还额外提供了一个独立的 Android SDK 平台工具软件包，都可以在 [这个网站](https://developer.android.google.cn/tools/releases/platform-tools?hl=zh-cn) 中下载到对应的版本。

- **USB 调试**

- **WLAN 调试（Android 10 及更低版本，需要借助 USB）**
- **Wi-Fi 调试（Android 11 及更高版本，无需借助 USB）**

Android 10以及更低的版本，必须通过 USB 连接后，才可实现同一 WLAN 下无线调试。

 



要在 Android 设备上执行 adb 指令，需要将 Android 手机和电脑使用 USB 数据线连接，在此之前我们还需要在手机的系统设置中启用「USB 调试」功能。

USB 调试功能位于「开发者选项」当中，在搭载 Android 4.2 及更高版本的设备上，开发者选项默认隐藏，要将其显示出来，我们需要在「设置 > 关于手机」中找到并连续点击七次**版本号**。

确保 USB 调试功能打开后并授予已连接计算机 USB 调试权限后，我们就可以使用各种各样的 adb 命令了。





adb 提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：

- 客户端：用于发送命令。客户端在开发机器上运行。您可以通过发出 adb 命令从命令行终端调用客户端。 
- 守护程序：守护程序 (adbd)：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。
- 服务器：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。





Android脱胎于Linux，不管其外在表面是多么的大家闺秀，还是多么的小家碧玉，其内在都有着邻家姑娘一样朴实无华过日子的心。与Linux一样，Android支持常见的命令，这些命令都保存在设备的/system/bin目录。

在这个目录下面我们可以看到平时在Linux系统下面常见的一些命令，如“ls、ps、df、time、kill”等。通过adb,我们可以以两种方法来调用这些命令：

**「交互式执行」**
　　交互式执行，即以不带参数的形式运行adb shell指令，打开一个交互式的shell环境，然后像使用本地Linux终端一样来输入并执行相关的命令。运行完毕要退出交互式shell环境，输入并执行命令“exit”即可。

**「直接执行」**
　　直接执行，即不打开交互式终端，由adb shell指令后面跟上要执行的指令及其参数组成。格式为“adb shell [COMMAND] [PARAMETER]”





# 刷机概述

大约十年前，搭载 Android 系统的手机刚刚兴起，Root、刷机、第三方 ROM 等词也随即流行起来：

点击十次 Android 版本号进入开发者模式；安装《360 手机助手》《刷机精灵》等软件一键获取根权限；卡刷、线刷第三方 ROM 包；清除系统自带 app、更改系统字体；安装《EX 文件管理器》《八门神器》更改游戏数据……

这一连串动作是第一代 Android 系统冒险者的美好回忆。



**root权限**

Root 这个单词，直接的含义是「根」，所谓：「你的手机 Root 了吗?」其实问的是你是否取得了手机的「根权限」。

Android 其实属于  Android/Linux  https://101.lug.ustc.edu.cn/Ch01/#smartphones

那么什么是手机的「根权限」呢？

对操作系统中的内容进行处理是需要权限的，涉及到的信息越重要，需要的权限级别就越高。手机中的「根权限」和电脑上的「管理员权限」是相似的，都是管理该系统的权限等级，只不过前者比后者级别更高。

可以说取得了 Root 权限就等于拥有了整个系统中至高无上的管理权，许多在原来「无权」的状态下不能做的事情，现在都可以做了，例如增、删、改手机中的系统文件等。



**刷机**

刷机这个词经常和另一个词——ROM 一起出现。如果能摸到的手机是个躯体的话，那么 ROM 里的东西就好比手机的灵魂。

ROM 意为「只读存储器」，它只能读取不能写入，第一次写入 ROM 后的信息就像刻在 DNA 里一样不能变更。这就是为何被我们使用很久的手机在恢复出厂设置以后，又能回到最初相见时的样子。

手机的 ROM 是用来存放手机固件代码（例如手机的系统）的地方，而刷机要刷的便是手机的固件。



刷机就是给android设备换操作系统的过程，以下三种刷机方式均能实现同样的更换系统的效果，但是三种刷机包的文件以及手机在刷机时的状态是不同的，要注意区分。



**Recovery是Android手机备份功能，指的是一种可以对安卓手机内部的数据或系统进行修改的模式（类似于windows PE或DOS）。在这个模式下可以，对已有的系统进行备份或升级，也可以在此恢复出厂设置。**

开机按住音量下键和电源键，直至手机振动一次，释放电源键但不要释放音量下键。进入recovery模式后，通过音量键上下键选择需要的操作，比如wipe cache partition（清除缓存分区）、factory reset（恢复出厂设置）等。



**卡刷（recovery）**

- 将完整的刷机包放入手机的 sdcard 中
- 手机进入 recovery 模式直接安装，整个安装不需要电脑参与
- 简单快捷，不易出错，适合新手



**线刷（fastboot）**

- 刷机包在电脑中，利用刷机软件对手机进行刷机
- 实际上手机进入了fastboot模式
- 需要电脑安装好手机驱动并连接
- 容易出错，一般用来救砖

**OTA（Android OS）**

- Over-The-Air 空中下载技术
- 就是手机设置中更新操纵系统，下载补丁包，文件不大
- 手机就在Android OS层面完成了补丁的下载，并自动更新
- 一般手机root后将不再提供系统更新	



**fastboot**

进入方式：开机+音量上（一般）

fastboot 主要是用来与bootloader的USB通讯的PC命令行工具。他一般主要也用来向bootloader传送刷机文件进行文件分区重烧。 

因此在使用时，必须有一个PC机并且USB线要始终联着。所以这种方式称为线刷。 用fastboot需要bootloader 支持，所以不是每一家公司产品都支的这个功能的。



**Bootloader**



使用最广泛的Bootloader是一个叫uboot的程序，它支持非常多的体系结构。

经过编译后，uboot会生成一个uboot.bin镜像。将这个镜像烧到设备上的一个特定分区去，就能够作为Bootloader使用了。

BL锁全称为Bootloader锁，其中Bootloader中文名称为“启动加载”。

在嵌入式操作系统中，BootLoader是在**操作系统内核**运行之前运行，它可以初始化硬件设备、建立内存空间映射图，从而将系统的软硬件环境带到一个合适状态，以便为最终调用操作系统内核准备好正确的环境。

在嵌入式系统中，通常并没有像BIOS那样的固件程序（注，有的嵌入式CPU也会内嵌一段短小的启动程序），因此整个系统的加载启动任务就完全由BootLoader来完成。

在一个基于ARM7TDMI core的嵌入式系统中，系统在上电或复位时通常都从地址0x00000000处开始执行，而在这个地址处安排的通常就是系统的BootLoader程序。再简单点来说就类似于电脑上的引导程序。Bootloader从字面上来看就是启动加载的意思。

用过电脑的都知道，Windows开机时会首先加载Bios，然后是系统内核，最后启动完毕。那么Bootloader就相当于手机的BIOS，它在手机启动的时候根据基带初始化硬件，然后引导系统内核，直到系统启动。

那么Bootloader锁就是限制用户刷第三方ROM和第三方Recovery以及限制Root的“锁”（并不是所有的手机Root都需要解BL锁，这个以后会讲）。

举个例子：如果一部手机上了BootLoader锁，就不能使用Recovery刷第三方rom包（每个刷机包都有签名，官方rec只会识别官方的刷机包），官方自带的Recovery也不允许用户刷入第三方rom包，需解了BootLoader替换Recovery才行。

一般来说手机厂商都会给自己的手机加上这个所谓的BL锁，防止因为刷机不当而导致手机损坏。

 归根结底BL所就是锁住手机的Recovery和Fastboot，防止刷入非官方签名的系统而损坏手机的一个保护机制（同时也为用户资料提供了一定的保护）。

 总结下解BL锁的作用：

- 对于一般用户，bootloader锁定根本没有影响
- 对于一般刷机来说，bootloader锁定可以大大减小死砖的几率
- 保护手机厂商的利益，因为你一旦解锁就没保修了嘛
- 防止JS肆意篡改手机信息的作用
- 保护手机里的个人资料

 我相信现在大家都明白BL锁是个啥东东了吧，那么有人可能就要问了，既然BL锁是为了保护手机和用户隐私那么为什么我们还要去解锁呢。

原因：不锁BL锁就不能自由刷机（只能通过官方Recovery刷入官方签名的ROM包，不可降级），不可以自定义操作系统。以及大部分手机不可以Root。

万一某天官方的最新系统你觉得不好用想退回原来的，Sorry，不行！你只能等到官方推送下一次系统更新，怎样？是不是感觉很不爽？所以我们这个时候就要进行解BL锁的操作了（这里提醒一下解BL锁有巨大的风险！！！）。  





嵌入式设备的ROM结构（NAND flash之类的芯片）。

通常。一个能够正常启动的嵌入式设备的ROM包括有下面四个分区：

- Bootloader分区，也就是存放uboot.bin的分区
-  Bootloader用来保存环境变量的分区
- Kernel分区。也就是存放OS内核的分区
- Rootfs分区，也就是存入系统第一个进程init相应的程序的分区





AOKP 的全称为“Android Open-Source Kang Project”，比AOSP 多了一个“Kang”。在Android社区中，Kang是一个术语，即用来表示这是一个被他人修改过的ROM，修改ROM的人不属于制作ROM的团队或没有该团队的授权。



**Galaxy Nexus AOKP** 

究其根本，没有原生AOSP，就没有AOKP。

AOKP 是由民间团队开发和维护的，相比原汁原味的AOSP，AOKP 显得更为激进，强大的MOD和丰富的自定义设置都让人无法忘却，但在功能强大的同时，不稳定始终是AOKP 无法撕下的标签。

对开发者而言，在有限的时间内做尽可能多的测试，才算对ROM使用者负责。





**CM（CyanogenMod）**





CM 是CyanogenMod 的简称，Cyanogen团队是全球最大的第三方ROM编译团队，覆盖机型范围相当之广，几乎所有热门机型都有相对应的CM ROM可以刷机使用。

国内知名ROM作品 MIUI 早期也是直接采用了CM 的源代码，才能迅速在多个机型上普及。



CyanogenMod 10

严格意义上来说，CM ROM 属于AOKP 的范畴。CM ROM 一直遵从原生Android，但只有Google 官方的才算真正的AOSP。

正因为有了后期的修改和优化，CM 比原生系统在自定义上更强一点，相信使用过CM ROM 的机友都对那强大的CM设置有印象。



