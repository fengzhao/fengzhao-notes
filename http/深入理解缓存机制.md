# 缓存总览——从性能优化的角度看缓存





## 缓存无处不在

> “计算机科学只存在两个难题：缓存失效和命名。””——Phil KarIton
>
> 



在计算的世界，缓存无处不在，我们知道常见各种缓存：

- CPU一级二级缓存
- redis缓存
- 数据库缓存
- 浏览器缓存
- 代理服务器缓存
- CDN缓存



## 浏览器加载资源的优先级

浏览器加载资源有很多不确定性，例如： 

- css/font的资源的优化级会比img高，资源的优化级是怎么确定的呢？
- 资源优先级又是如何影响加载的先后顺序的？
- 有几种情况可能会导致资源被阻止加载



当浏览器开始解析网页，并开始下载图片、`Script` 以及 `CSS` 等资源的时候，浏览器会为每个资源分配一个代表资源下载优先级的 `fetch priority` 标志。

浏览器按照资源被发现的顺序下载具有相同计算优先级的资源。

> Chrome开发者工具中网络面板`DevTools Network`中可以每个资源的优先级，如果没有看到该列，您可以通过右键单击列标题来启用"优先级"列。

而资源下载的顺序就取决于这个优先级标志，这个优先级标志的计算逻辑会受很多因素的影响：

- `Script`、`CSS`、`Font`、`Image` 等不同的资源类型会有不同的优先级。
- 在 `HTML文档` 中引用资源的位置或顺序也会影响资源的优先级（例如在 `viewport` 中的图片资源可能具有高优先级，而在 `<link>` 标签中加载的，阻塞渲染的 `CSS` 则拥有更高的优先级）。
- 有 `preload` 属性的资源有助于浏览器更快地发现资源、其实也是影响资源加载的优先级。
- `Script` 的 `async` 或 `defer` 属性都会影响它的优先级。



https://web.dev/priority-hints/

https://sylvenas.github.io/blog/2019/01/12/load-priority.html

https://cloud.tencent.com/developer/article/1909441





## 缓存的作用



重用已获取的资源，减少延迟与网络阻塞，进而减少显示某个资源所用的时间，借助 HTTP 缓存，Web 站点变得更具有响应性。

其实我们对于页面静态资源的要求就两点：

- 静态资源加载速度
- 页面渲染速度

页面渲染速度建立在资源加载速度之上，但不同资源类型的加载顺序和时机也会对其产生影响，所以缓存的可操作空间非常大。

缓存的一些典型缓存应用场景：

- 每次都加载某个同样的静态文件 => 浪费带宽，重复请求 => 让浏览器使用本地缓存（协商缓存，返回304）
- 协商缓存还是要和服务器通信啊 => 有网络请求，不太舒服，感觉很low => 强制浏览器使用本地强缓存（返回200）
- 缓存更新，



## WEB缓存

在 HTTP/1.1 中，缓存通过复用一个之前的响应消息来满足当前的请求，其目的是显著提升性能。

> 比如你上午访问过淘宝首页，一些静态资源（html,css,js,font等）已经缓存到本地浏览器了，下午再访问，都可以直接从浏览器缓存中请求这些资源。



**缓存新鲜度检测**

一个已存储的响应，如果它在不需要"**验证**"的情况就可以用来复用，那么，它被认为是"**新鲜的**"。

为了有效地进行再验证，HTTP 定义了一些特殊的请求，不用从服务器上获取整个对象，就可以快速检测出内容是否是最新的。



**服务器再验证**

仅仅是已缓存文档过期了并不意味着它和原始服务器上目前处于活跃状态的文档有实际的区别；这只是意味着到了要进行核对的时间了。

这种情况被称为“服务器再验证”，说明缓存需要询问原始服务器文档是否发生了变化。



- 如果再验证显示资源发生了变化，缓存会获取一份新的资源副本，并将其存储在旧资源的位置上，然后将资源发送给客户端。
- 果再验证显示内容没有发生变化，缓存只需要获取新的首部，包括一个新的过期日期，并对缓存中的首部进行更新就行了。



缓存并不一定要为每条请求验证文档的有效性——只有在资源过期时它才需要与服务器进行再验证。这样不会提供陈旧的内容，还可以节省服务器的流量，并拥有更好的用户响应时间。





条件方法再验证



`Last-Modified`与`If-Modified-Since`属于HTTP/1.0，是用于服务端对响应数据修改时间进行校验的服务端校验方法。

`Last-Modified`的值是由服务端生成后传递给客户端的。

客户端发送请求时，会将本地内容缓存中的`Last-Modified`的值由请求消息头的`If-Modified-Since`字段传递给服务端，如果服务端的被请求的内容的最后修改时间和`If-Modified-Since`的（默认是exact精确匹配）值不一致，则将返回新的内容，否则返回响应状态码304，客户端将使用本地缓存。







HTTP 允许缓存向原始服务器发送一个"条件 GET"，请求服务器只有在文档与缓存中现有的副本不同时，才回送对象主体。通过这种方式，将新鲜度检测和对象获取结合成了单个条件 GET。

向 GET 请求报文中添加一些特殊的条件首部，就可以发起条件 GET。只有条件为真时，Web服务器才会返回对象。

 **If-Modified-Since** 

将这个首部添加到 GET 请求中去，就可以告诉服务器，只有在缓存了对象的副本之后，又对其进行了修改的情况下，才发送此对象。



返回结果分为三种：





## 缓存控制



### Expires

Expires 是 http1.0 提出的一个表示资源过期时间的 header，它是一个由浏览器返回的绝对时间。
Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

```http
Expires: Wed, 21 Oct 2015 07:28:00 GMT
```







### 强缓存 Cache-Control

[Cache-Control](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control) 出现于 HTTP / 1.1，优先级高于 Expires ，表示的是相对时间。



**可缓存性**

- `Cache-Control: no-cache`  在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证 (协商缓存验证)。
- `Cache-Control: no-store` 才是真正的不缓存数据，包括各种代理，客户端都不缓存。

- `Cache-Control: public` 可以被所有用户缓存（多用户共享），包括终端和CDN等中间代理服务器
- `Cache-Control: private` 表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器CDN等不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。

**到期**

- 

```http
max-age=<seconds>
```

设置缓存存储的最大周期，超过这个时间缓存被认为过期(单位秒)。与`Expires`相反，时间是相对于请求的时间。

```http
s-maxage=<seconds>
```

覆盖`max-age`或者`Expires`头，但是仅适用于共享缓存(比如各个代理)，私有缓存会忽略它。

```http
max-stale[=<seconds>]
```

表明客户端愿意接收一个已经过期的资源。可以设置一个可选的秒数，表示响应不能已经过时超过该给定的时间。

```http
min-fresh=<seconds>
```

表示客户端希望获取一个能在指定的秒数内保持其最新状态的响应。

```
stale-while-revalidate=<seconds>
```

表明客户端愿意接受陈旧的响应，同时在后台异步检查新的响应。秒值指示客户愿意接受陈旧响应的时间长度。

```
stale-if-error=<seconds>
```

表示如果新的检查失败，则客户愿意接受陈旧的响应。秒数值表示客户在初始到期后愿意接受陈旧响应的时间。





### prefetch预提取

prefetch(链接预取）是一种浏览器机制，其利用浏览器空闲时间来下载或预取用户在不久的将来可能访问的文档。

**向浏览器通知将来需要的资源来加速页面的后续展现，例如，如果用户采取了我们期望的操作，则我们可以提前加载稍后可能需要的东西。**

网页向浏览器提供一组预取提示，并在浏览器完成当前页面的加载后开始静默地拉取指定的文档并将其存储在缓存中。当用户访问其中一个预取文档时，便可以快速的从浏览器缓存中得到。

具体来说，浏览器通过标签来实现预加载。其中rel="prefetch"被称为Resource-Hints（资源提示），也就是辅助浏览器进行资源优化的指令。

```html
<head>
    ...
    <link rel="prefetch" href="static/img/ticket_bg.a5bb7c33.png">
    ...
</head>
```



### preload预加载



## 公有代理缓存



公有缓存是特殊的共享代理服务器，被称为缓存代理服务器（caching proxy server），或者更常见地被称为代理缓存（proxy cache）

代理缓存会从本地缓存中提供文档，或者代表用户与服务器进行联系。公有缓存会接受来自多个用户的访问，所以通过它可以更好地减少冗余流量。

一个典型的公有代理缓存就是 **CDN** 