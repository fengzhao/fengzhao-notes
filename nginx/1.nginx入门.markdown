# Nginx 介绍



Nginx ("engine x") 是一个高性能的 HTTP 和反向代理服务器，也是一个 IMAP/POP3/SMTP 代理服务器。

Nginx 是由 Igor Sysoev 为俄罗斯著名的 Rambler.ru 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。

其将源代码以类 BSD 许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。

由于 Nginx 使用基于事件驱动的架构，能够并发处理百万级别的 TCP 连接，高度模块化的设计和自由的许可证使得扩展 Nginx 功能的第三方模块层出不穷。

因此其作为 Web 服务器被广泛应用到大流量的网站上，包括淘宝、腾讯、新浪、京东等访问量巨大的网站。

2015 年 6 月，Netcraft 收到的调查网站有 8 亿多家，主流 web 服务器市场份额（前四名）如下表：

| Web服务器         | 市场占有率 |
| :---------------- | :--------: |
| Apache            |   49.53%   |
| Nginx             |   13.52%   |
| Microsoft IIS     |   12.32%   |
| Google Web Server |   7.72%    |

其中在访问量最多的一万个网站中，Nginx 的占有率已超过 Apache。



Nginx 是一个高性能的 Web 服务器，从 2001 年发展至今，由于 Nginx 对硬件和操作系统内核特性的深度挖掘，使得在保持高并发的同时还能够保持高吞吐量。

Nginx 还采用了模块设计，有大量的第三方模块可以扩展 Nginx 的功能，因此 Nginx 的场景非常丰富，同时 Nginx 采用的是 BSD 许可证，赋予了 Nginx 最大的灵活性。

简单来说，Nginx 具有以下几个优点：


- 速度快
- 高并发，高性能
- 可扩展性好
- 高可靠，一年之中停机时间可能只有几秒
- 热部署，可以不重启升级
- 灵活性高，采用BSD 许可证



> BSD开源协议是一个给予使用者者很大自由的协议。
>
> 基本上使用者可以“为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。



截止 2019 年 9 月份，Nginx 的市场份额已经达到了 33%，且还在持续增长，稳居市场头把交椅。



## 诞生背景

Nginx 出现的背景是由于互联网的快速普及导致数据量的快速增长，同时催生出了海量的连接。

传统的 Apache 等服务器采用的是单进程模型，这意味着，每处理一个请求就会创建一个进程，这不但存在进程创建的开销。

而且进程之间相互切换产生的上下文开销也非常耗费 CPU 资源，导致这种传统的服务器在面对成千上万的并发连接时，性能非常低下，而这是快速发展的互联网所不能够忍受的。

在这种背景下，Nginx 采用的是进程池和 epoll 处理模型，这二者加起来使得 Nginx 的性能非常优异，一台 32 核的机器上可以支撑数千万的并发连接。

Nginx 有一个 master 进程和若干个 worker 进程。

master 进程是用来管理 worker 进程的，worker 进程负责处理具体的请求，worker 进程是 master 进程的子进程。

Nginx服务器的一个显著优势是能够同时处理大量并发请求。它结合多进程机制和异步机制对外提供服务，异步机制使用的是异步非阻塞方式

Nginx服务器启动后，可以产生一个主进程（master process）和多个工作进程（worker processes），其中可以在配置文件中指定产生的工作进程数量。

Nginx服务器的所有工作进程都用于接收和处理客户端的请求。这类似于Apache使用的改进的多进程机制，预先生成多个工作进程，等待处理客户端请求。

每个工作进程使用了异步非阻塞方式，可以处理多个客户端请。当某个工作进程接收到客户端的请求以后，调用IO进行处理，如果不能立即得到结果，就去处理其他的请求；

而客户端在此期间业务需等待响应，可以去处理其他的事情；当IO调用返回结果时，就会通知此工作进程；该进程的到通知，暂时挂起当前处理的事务，去响应客户端请求。

客户端请求数量增长、网络负载繁重时，Nginx服务器使用多进程机制能够保证不增长对系统资源的压力；同时使用异步非阻塞方式减少了工作进程在I/O调用上的阻塞延迟，保证了不降低对请求的处理能力。



## Nginx 及其周边

介绍完 Nginx 的背景，我们就该说说 Nginx 周边了。目前基于 Nginx 二次开发的软件主要如下：

- 官方 Nginx。包含开源版（nginx.org）和商业版（nginx.com）
- [freenginx](https://freenginx.org/en/)
- [Tengine](https://tengine.taobao.org/)，Tengine 是由淘宝网发起的 Web 服务器项目，目前已经开源。
- [OpenResty](https://openresty.org/cn/)，OpenResty 通过 Lua 对 Nginx 进行扩展，使得扩展 Nginx 模块变得异常轻松
- [kong](https://github.com/Kong/kong)，Kong Gateway (OSS) ，Kong是一个云原生，快速，可扩展和分布式微服务的开源API网关。
- [apisix](https://apisix.apache.org/zh/)，Apache APISIX 是一个动态、实时、高性能的云原生 API 网关，提供了负载均衡、动态上游、灰度发布、服务熔断、身份认证等功能。



最近，F5 前雇员、Nginx 项目主要贡献者`Maxim Dounin `发布了 Nginx 的分支 Freenginx。这个新项目是为了解决一个安全争议，并希望成为 Nginx 的可替代方案，由开发人员而不是企业实体负责运营。

Maxim Dounin，nginx开发的重要人物，宣布推出freenginx.org，这是一个新项目，旨在在没有企业控制的情况下继续开发nginx。此举是在F5收购nginx后，该公司做出了违背开源精神和`Dounin`之前与他们达成的协议的决定。

Dounin的举措非常重要，因为它代表了开发者主导项目和维护开源工作完整性对抗企业利益的立场。对于关心nginx在F5管理下的发展方向并有兴趣支持或贡献于以社区和开发者意见为重的替代方案的开发者和用户来说，这一公告尤为重要。





针对我们日常工作学习来说，选择官方开源版的 Nginx 或者 OpenResty 就可以了。

### Nginx 版本策略

------

在 Nginx 的[开源代码库](http://hg.nginx.org/nginx/branches)中，有两种分支，分别是 mainline 和 stable。

-  Mainline 相当于开发分支，更新比较活跃，包含引入一些新的功能或者bug修复，版本号的第二个数字如果是奇数，那就是 Mainline 版本，比如 1.17.0。
- Stable 分支很容易理解，就是相对稳定的版本，除非有重大Bug，否则在它的生命周期内不会更新，版本号的第二个数字如果是偶数，那就是 Mainline 版本，比如 1.16.0。

对于 NGINX 开源，“稳定”一词指的是功能和更新频率，而不是软件质量。稳定分支在其生命周期中从不接收新功能，通常只接收一两个更新，用于关键错误修复。

stable 版本代表功能多少和更新频率，和软件质量没有太大的关系（当然任何软件都会有Bug）。

在每年4月份会发布一次，它的生命周期是一年，在这段时间内，一般情况不会更新版本号（除非有重大Bug）。

https://www.cnblogs.com/91donkey/p/11639355.html





# 安装 Nginx 和 OpenResty

在 Linux 上，当然可以使用 yum、apt-get 等软件包管理工具来下载 Nginx，但是 Nginx 的很多模块并不是默认开启的，第三方模块很多也并不包含。

所以，如果想要开启内置的模块或编译第三方模块，还是需要编译 Nginx。



### 包管理器安装 nginx

------

```shell
# https://www.nginx.com/resources/wiki/start/topics/tutorials/install/

# 配置yum源：/etc/yum.repos.d/nginx.repo 

# CentOS
[nginx]
name=nginx repo
# 系统:CentOS7 架构:x86_64
baseurl=https://nginx.org/packages/centos/7/x86_64/

# 系统:CentOS8 架构:x86_64
# baseurl=https://nginx.org/packages/centos/7/x86_64/

# 系统:RHEL7 架构:x86_64
# baseurl=https://nginx.org/packages/rhel/7/x86_64/

# 系统:RHEL8 架构:x86_64
# baseurl=https://nginx.org/packages/rhel/7/x86_64/
gpgcheck=0
enabled=1


```



### 编译安装Nginx

在 <http://nginx.org/en/download.html> 里面可以直接下载 Nginx 源代码。包含以下目录：

```shell
# 添加运行nginx的用户
groupadd nginx
useradd -r -g nginx -s /bin/false nginx


# 安装依赖环境，确保编译正常
sudo yum install gcc gcc-c++ make automake autoconf libtool pcre* zlib openssl openssl-devel  pcre pcre-devel

sudo apt install zlib1g zlib1g-dev curl gnupg2 ca-certificates lsb-release ubuntu-keyring dirmngr software-properties-common apt-transport-https   gcc make libpcre3 libpcre3-dev   zlib1g-dev openssl libssl-dev 

# 在 http://nginx.org/en/download.html 里面下载 Nginx 源代码，永远下载最新的Stable release版本
wget http://nginx.org/download/nginx-1.21.6.tar.gz


# https://www.cnblogs.com/chrdai/p/11306728.html
nginx-1.21.4
├── CHANGES 		# 每个版本提供的特性和 bugfix，changelog文件
├── CHANGES.ru 		# 俄罗斯版本的 CHANGES 文件
├── LICENSE			# 开源许可文件
├── Makefile        #    
├── README          # README说明文件
├── auto # 自动检测系统环境以及编译相关的脚本，辅助 configure 脚本执行的时候去判定nginx支持哪些模块，当前操作系统有什么样的特性可以供给nginx使用
├── conf # 示例文件，方便运维配置，会把 conf 示例文件拷贝到安装目录
├── configure # 命令脚本，用来生成中间文件，执行编译前的一个必备动作
├── contrib # 提供了两个 pl 脚本和 vim 工具
├── html # 一个 500 错误的默认页面，另一个是默认的 index 页面
├── man # nginx 对 Linux 的帮助文件，man ./nginx.8
└── src # nginx 核心源代码


# 配置 Vim 高亮, 如果 Vim 没有开启语法高亮的话，最好开启一下。如果没有 ~/.vim 文件夹就新建一个
cp -r contrib/vim/* ~/.vim
echo 'syntax on' > ~/.vimrc 

# 在 vim ~/.vim/ftdetect/nginx.vim 文件中指定，哪些文件，需要按照nginx的语法进行高亮显示
au BufRead,BufNewFile *.nginx set ft=nginx
au BufRead,BufNewFile */etc/nginx/* set ft=nginx
au BufRead,BufNewFile */usr/local/nginx/conf/* set ft=nginx
au BufRead,BufNewFile */usr/local/nginx/conf/* set ft=nginx




# Nginx是在 /usr/local/lib; /usr/pkg/lib; /opt/local/lib; 这三个路径下去查找OpenSSL library PATH
# 有时候因为nginx升级之后使用了高版本的Openssl，本地需要添加新模块重新编译nginx时候要升级openssl至指定版本。

# configure配置，configure之后，会生成Makefile文件，用于编译和构建nginx
./configure   --user=nginx --group=nginx  --prefix=/usr/local/nginx/  --with-http_stub_status_module  --with-http_ssl_module


# 如果打算用源码的高版本openssl，那编译时候用./configure --with-http_ssl_module --with-openssl=/usr/local/openssl-1.0.2k

# 等号后面的绝对路径或者相对路径就是openssl的源码包tar.gz解压出来的目录，就是里面有目录啊，config二进制文件啊，README啦那些。

# https://blog.51cto.com/meiling/2165811
./configure   --user=nginx --group=nginx  --prefix=/usr/local/nginx/  --with-http_stub_status_module  --with-http_ssl_module --with-stream  --with-openssl=/usr/local/openssl/  


./configure --help # --help 命令可以查看配置脚本支持哪些参数

# 第一类配置参数

--prefix=PATH                      set installation prefix      # 一般指定这个路径就可以了，其他文件会在 prefix 目录下建立相应的文件夹
--sbin-path=PATH                   set nginx binary pathname
--modules-path=PATH                set modules path
--conf-path=PATH                   set nginx.conf pathname
--error-log-path=PATH              set error log pathname
--pid-path=PATH                    set nginx.pid pathname
--lock-path=PATH                   set nginx.lock pathname
--user=USER                        set non-privileged user for worker processes
--group=GROUP                      set non-privileged group for worker processes
--build=NAME                       set build name
--builddir=DIR                     set build directory



# 第二类配置参数
# 可以配置使用或不使用哪些模块，前缀通常是 with 和 with out。
## with开头的表示该模块默认是未开启的，可以使用--with开启。
## without开头的表示该模块默认是启用的，可以使用--without禁用。
## 第三方模块使用--add-module=PATH添加。如果支持动态加载，使用--add-dynamic-module=PATH添加。

--with-http_ssl_module             enable ngx_http_ssl_module
--with-http_v2_module              enable ngx_http_v2_module
--with-http_realip_module          enable ngx_http_realip_module
...
--without-http_charset_module      disable ngx_http_charset_module
--without-http_gzip_module         disable ngx_http_gzip_module
--without-http_ssi_module          disable ngx_http_ssi_module
...


make && make install 



# nginx服务配置文件，使用systemd
# /lib/systemd/system/nginx.service
# https://www.nginx.com/resources/wiki/start/topics/examples/systemd/

[Unit]
Description=The NGINX HTTP and reverse proxy server
After=syslog.target network-online.target remote-fs.target nss-lookup.target
Wants=network-online.target
[Service]
Type=forking
PIDFile=/usr/local/nginx/logs/nginx.pid
ExecStartPre=/usr/local/nginx/sbin/nginx -t
ExecStart=/usr/local/nginx/sbin/nginx
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/bin/kill -s QUIT $MAINPID
PrivateTmp=true
[Install]
WantedBy=multi-user.target
```



**配置 Vim**

如果 Vim 没有开启语法高亮的话，最好开启一下

```shell
cp -r contrib/vim/* ~/.vim
# mac 下需要在家目录下新建 .vimrc 文件并配置
syntax on
```



### 编译 Nginx

```shell
./configure --help # --help 命令可以查看配置脚本支持哪些参数


# 第一类配置参数

--prefix=PATH                      set installation prefix # 指定这个路径就可以了，其他文件会在 prefix 目录下建立相应的文件夹
--sbin-path=PATH                   set nginx binary pathname
--modules-path=PATH                set modules path
--conf-path=PATH                   set nginx.conf pathname
--error-log-path=PATH              set error log pathname
--pid-path=PATH                    set nginx.pid pathname
--lock-path=PATH                   set nginx.lock pathname
--user=USER                        set non-privileged user for worker processes
--group=GROUP                      set non-privileged group for worker processes
--build=NAME                       set build name
--builddir=DIR                     set build directory



# 第二类配置参数
# 可以配置使用或不使用哪些模块，前缀通常是 with 和 with out，需要加 with 参数的通常是不会被 Nginx 默认编译的，without 则是会移出编译。
## 比如说--with-http_ssl_module或者--with-http_v2_module，通常需要主动加--with的时候，意味着模块默认是不会编译进nginx的。


--with-http_ssl_module             enable ngx_http_ssl_module
--with-http_v2_module              enable ngx_http_v2_module
--with-http_realip_module          enable ngx_http_realip_module
...

## 比如说--without-http_charset_module意味着默认他会编译进nginx中，加了参数是把他移除默认的nginx的模块中。
--without-http_charset_module      disable ngx_http_charset_module
--without-http_gzip_module         disable ngx_http_gzip_module
--without-http_ssi_module          disable ngx_http_ssi_module
...





 # 1. 使用默认参数，进行 configure 指定编译安装目录
./configure --prefix=/usr/localnginx/
 # 编译完成后生成 objs 文件夹中间文件
➜   ls -al 
total 176
-rw-r--r--  1 mtdp  staff    40K  3  3 07:23 Makefile
-rw-r--r--  1 mtdp  staff    25K  3  3 07:23 autoconf.err
-rw-r--r--  1 mtdp  staff   5.4K  3  3 07:23 ngx_auto_config.h
-rw-r--r--  1 mtdp  staff   531B  3  3 07:23 ngx_auto_headers.h
-rw-r--r--  1 mtdp  staff   5.7K  3  3 07:23 ngx_modules.c # ngx_modules.c 决定了接下来的编译会生成哪些模块
drwxr-xr-x  9 mtdp  staff   288B  3  3 07:23 src
2. # 编译
make # 生成了大量的中间文件。如果是版本升级，就不能直接 makeinstall，需要将 obj 拷贝到安装目录。如果生成了动态模块，编译后也会放在 objs 目录下
3. # 安装
make install
➜  nginx ll # 安装完成后生成以下文件夹
total 0
drwxr-xr-x  17 mtdp  staff   544B  3  3 07:29 conf # 从 Nginx 源码目录拷贝的
drwxr-xr-x@  4 mtdp  staff   128B  3  3 07:29 html # 从 Nginx 源码目录拷贝的
drwxr-xr-x   2 mtdp  staff    64B  3  3 07:29 logs # 日志文件目录，包括 access log 和 error log
drwxr-xr-x   3 mtdp  staff    96B  3  3 07:29 sbin # Nginx 二进制文件目录
```



### Nginx 安装第三方模块

第三模块是对nginx 的功能扩展，第三方模块需要在编译安装nginx 的时候使用参数--add-module=PATH指定路径添加。

有的模块是由公司的开发人员针对业务需求定制开发的。

有的模块是开源爱好者开发好之后上传到github进行开源的模块，nginx支持第三方模块，需要重新编译源码才能支持。



**安装nginx安装第三方模块** 实际上是使用--add-module重新编译**安装**一次**nginx**，

不要 make install 而是直接把编译目录下 objs/**nginx **文件直接覆盖老的 **nginx **文件。如果你需要**安装**多个**nginx第三方模块**,你只需要多指定几个相应的--add-module即可



### 编译 OpenResty

OpenResty 的编译安装步骤与 Nginx 基本一致

在 <https://openresty.org/en/download.html> 中下载 OpenResty 的源代码，然后按照 Nginx 的编译步骤执行即可。

```bash
wget  https://openresty.org/download/openresty-1.21.4.1.tar.gz
```







# Nginx 配置文件





```nginx
events {
    worker_connections 1024;
}

http {
    #incloud mime.types;
    #default_type application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    #access_log logs/geek.access.log main;
    sendfile on;
    #tcp_nopush on;
    #keepalive_timeout 0;
    keepalive_timeout 65;

    gzip on;
    gzip_min_length 1;
    gzip_comp_level 2;
    gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png multipart/form-data;
    server {
        listen 8080;
        server_name 127.0.0.1;
        #charset koi8-r;
        access_log logs/geek.access.log main;
        location /lua {
            default_type text/html;
            content_by_lua '
			ngx.say("User-Agent: ", ngx.req.get_headers()["User-Agent"])
			';
			}
        }
        #error_page 404 /404.html;

    }
```





如上所示，是一个非典型的 Nginx 配置文件，Nginx 的配置文件语法遵循以下规则：

- 配置文件由指令与指令块构成
- 每条指令以 ; 结尾，指令与指令的参数之间以空格符号分割
- 指令块以 {} 将多条指令组织在一起

```
events { # 指令块
    worker_connections 1024; # 指令
}
```

- include 语句允许组合多个配置文件，以提升可维护性
- 使用 # 添加注释
- 使用 $ 符号添加变量
- 部分指令的参数支持正则表达式

## 配置参数

### 时间单位

- ms：毫秒
- s：秒
- m：分钟
- h：小时
- d：天
- M：月 = 30 天
- y：年 = 365 天

### 空间单位

- bytes
- k/K：kilobytes
- m/M：megabytes
- g/G：gigabytes

## HTTP 配置的指令块

- http：表示由 http 模块来处理请求
- upstream：表示上游服务器地址
- server：表示站点地址
- location：表示 URL

这些指令块在接下来都会遇到。







# Nginx 命令行

在刚刚编译完成的 Nginx 目录下，有一个 sbin 目录，就是用来存放 Nginx 的二进制文件的

```
➜  sbin ll
total 1712
-rwxr-xr-x  1 mtdp  staff   854K  3  3 07:29 nginx
```

Nginx 启动时，有一系列的命令行参数可以指定，下面分别介绍一下。

```
./nginx
-h/-? # 打开帮助
-c # 使用指定的配置文件，而不是默认的 conf 文件夹下的配置文件
-g # 指定配置命令，覆盖掉配置文件中的指令
-p # 指定运行目录
-s # 发送信号 stop 立刻停止服务；quit 优雅的停止服务；reload 重载配置文件；reopen 重新开始记录日志文件
-t/-T # 测试配置文件是否有语法错误
-v/-V # 打印 nginx 的版本信息、编译信息等
```



## 热部署

当配置文件发生变更时，需要重载配置文件：

```
nginx -s reload
```



# 升级

但想要更换或者升级 nginx 版本时，就需要采用热部署的方式：

1. 查看现有 master 进程的 pid。可以看出来，worker 进程是 master 进程的子进程





# Nginx 配置指令





nginx.conf 文件是 nginx 中的核心文件，用于控制 nginx 的运行。



一个典型的 nginx 配置文件如下：

```nginx
main

http {
    upstream { … }
    split_clients {…}
    map {…}
    geo {…}
    server {
        if () {…}
        location {
            limit_except {…}
        }
        location {
            location {
            }
        }
    }
    server {
    }
}
```





## 指令块的嵌套



在 Nginx 配置文件中，指令块是可以嵌套分层的，例如上面的示例，http 块中可以包含多个 server 块，server 块中还会包含多个 location 块，每一个块中都有相应的指令。



而每一个指令都有 Context 上下文，也就是生效的环境，这在 Nginx 的官方文档中说的很清楚，例如下面的两条指令，Context 中都表明了各自可以生效的环境，access_log 指令可以在多个上下文中生效：



```nginx
Syntax:  access_log path [format [buffer=size] [gzip[=level]] [flush=time] [if=condition]];
         access_log off;
Default: access_log logs/access.log combined; 
Context: http, server, location, if in location, limit_except

Syntax:  log_format name [escape=default|json|none] string ...;
Default: log_format combined "..."; 
Context: http
```





## 指令的继承



既然 nginx 指令是可以嵌套分层的，而且指令可以存在于多个上下文环境。所以必然存在指令的继承。

例如下面的配置文件，这里面在 server 块和 location 块中都配置了 root 指令，Nginx 的继承规则如下：

- 子配置不存在时，直接使用父配置块的指令
- 子配置存在时，覆盖父配置块



```nginx
server {
    listen 8080;
    root /home/geek/nginx/html;
    access_log logs/geek.access.log main;
    location /test {
        root /home/geek/nginx/test;
        access_log logs/access.test.log main;
    }
    location /dlib {
        alias dlib/;
    }
    location / {
    }
}    
```



根据上面这两条规则，第一个 location 使用自己的 root 指令，后面两个 location 则使用 server 块的 root 指令。

这和编程语言中变量的作用域也是类似的，作用域更小的变量优先级往往更高，Nginx 的指令也是一样。



## 常用 nginx 指令





### http 指令

http 是最顶层的指令之一了，它必须直接在 main 中使用。

```nginx
# 指定运行nginx进程的用户，Default: nobody，
user nginx;  
# 工作进程数，等于CPU核数
worker_processes  auto;  
error_log  logs/error.log;
pid        logs/nginx.pid;
worker_rlimit_nofile 8192;

events {
  worker_connections  4096;  ## Default: 1024
}

http {
  include    conf/mime.types;
  include    /etc/nginx/proxy.conf;
  include    /etc/nginx/fastcgi.conf;
  index    index.html index.htm index.php;

  default_type application/octet-stream;
    
  server { # php/fastcgi
    listen       80;
    server_name  domain1.com www.domain1.com;
    access_log   logs/domain1.access.log  main;
    root         html;

    location ~ \.php$ {
      fastcgi_pass   127.0.0.1:1025;
    }
  }  
    
    server {
       ...
    }
    
}    

```



### server 指令 

server 是 nginx 中最重要的指令了，它必须被包含在 http 指令中使用。一个 server 就定义了一个虚拟主机。http块中可以有多个 server，可以让 nginx 支持多个虚拟主机。

虚拟主机是一种特殊的软硬件技术，它可以将网络上的每一台计算机分成多个虚拟主机，每个虚拟主机可以独立对外提供 www 服务，这样就可以实现一台主机对外提供多个 web 服务，每个虚拟主机之间是独立的，互不影响的。通俗说，一个虚拟主机就是一个网站。

```
Syntax:	server { ... }
Default:	—
Context:	http
```

### server_name 指令

server_name 指令是用来配置究竟是哪个 server 块来处理我们的请求的。它必须在 server 块中使用。

- server_name 指令后可以跟多个域名，第一个是主域名，多个域名之间空格分隔。
- 泛域名：仅支持在最前或最后加 * 通配符匹配任意字符串，例如：`*.demo.com` 和 `test.nginx.*`
- 正则表达式匹配：`server_name www.taohui.tech ~^www\d+\.taohui\.tech$;`



```nginx
Syntax:	server_name name ...;
Default:	
server_name "";
Context:	server
```



nginx 是如何处理一个请求的，假设有这样一个配置文件，配置了三个域名。

```nginx
server {
    listen      80;
    server_name example.org www.example.org;
    ...
}

server {
    listen      80;
    server_name example.net www.example.net;
    ...
}

server {
    listen      80;
    server_name example.com www.example.com;
    ...
}
```

当 nginx 接收到 http 请求时，先从请求头提取到 Host 头部字段，然后跟 server_name 匹配来确认是哪个server块来处理请求。

如果都不匹配，那么就用这个端口号的 default server 来处理。

在这个例子中，就是第一个来处理。——这是nginx的标准做法。也可以在端口号后面加上一个 default_server 来显示指定这个行为。

```nginx
server {
    listen      80 default_server;
    server_name example.net www.example.net;
    ...
}
```

**注意在这个配置中，default_server只是跟在端口后面，并没有配置在域名上面。 **



对于请求头中没有Host头部的请求，如果要禁止访问，可以设置如下配置：没有host头部的请求就会被这个server匹配上，并返回非标准的444状态码关闭连接。

```nginx
# 
server {
    listen      80 default_server;
    server_name "";
    return      444;
}
```





server_name 指令是用来配置究竟是哪个 server 来处理我们的请求的。有时候，一个 server_name 中可能会有多个域名，这时候是如何选择的呢？

1. server_name 指令后可以跟多个域名，第一个是主域名，多个域名之间空格分隔
2. 泛域名：仅支持在最前或最后加 *，例如：`server_name *.taohui.tech`
3. 正则表达式匹配：`server_name www.taohui.tech ~^www\d+\.taohui\.tech$;`

当 server_name 指令后有多个域名时，会有一个 `server_name_in_redirect` 的配置，这个配置默认关闭，它使用来控制域名重定向的，也就是这个配置开启之后，请求过来会重定向到主域名访问。

```nginx
Syntax  server_name_in_redirect on | off;
Default server_name_in_redirect off; 
Context http, server, location
```





### listen 指令

listen 指令在 server 块中生效，用来配置监听哪些网络接口地址，哪些端口，由这些端口来处理请求。listen 指令的配置语法如下：

```nginx
Syntax:	listen address[:port] [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
listen port [default_server] [ssl] [http2 | spdy] [proxy_protocol] [setfib=number] [fastopen=number] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];
listen unix:path [default_server] [ssl] [http2 | spdy] [proxy_protocol] [backlog=number] [rcvbuf=size] [sndbuf=size] [accept_filter=filter] [deferred] [bind] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];

# 默认值
Default:	 listen *:80 | *:8000;

# 只能出现在server块中
Context:	server



# 常见的litsen配置语法

listen 443 ssl http2; # 监听443，开启https，开启http2协议
# 对于nginx1.25之后，需要用单独的指令"http2 on"这样来配置，不支持在litsen后面这样写了。
# 参见：http://nginx.org/en/docs/http/ngx_http_v2_module.html


listen 127.0.0.1:8080;
listen 8080;
listen *:8080;
listen *:8080;



```



### root指令

root 指令指定了 Nginx 查找文件的根目录，适用与`server` 和 `location`。可以指定多个，如果 `locaiton` 中没有指定，会往其外层的 `server` 或 `http` 中寻找继承。



```nginx
location /request_path/image/ {
	root /local_path/image/;
}
```



这样配置的结果就是当客户端请求 `/request_path/image/cat.png` 时，`Nginx` 把请求映射为 `/local_path/image/request_path/image/cat.png`



```nginx
location /static {
	root /var/www/html/static;
}

# 对于这个配置
# 我们访问http://127.0.0.1/static/stc.jpg，发现并不能显示图片，通过查看`error.log`发现我们最后访问的地址是`/var/www/html/static/static/stc.jpg`。所以 root 中配置的路径要去掉最后的`static`。
```

**其实就是将访问的地址进行拼接了上去**



```nginx
location /static {
	root /var/www/html;
}

location /static/ {
	root /var/www/html;
}


# 如果在location最后多加一个斜杠/，这样一来最后拼接后变成了这样/var/www/html/static//stc.jpg，这样并不会影响我们访问资源，因为在nginx中，多个斜杠/和一个斜杠/是等价的。


# 配置 location /static 可以匹配 /static/content.js 这种请求，也可以匹配 /static11/ 等等，只要以 wandou 开头的目录都可以匹配到。
# 配置 location /wandou/ 必须精确匹配 /wandou/ 这个目录的请求,








```



**有时候访问的地址要求后面以 / 结尾，如果用户忘记输入 /，Nginx 就会自动加上 /**

```nginx
server {
	listen	80;
	server_name localhost;
	location / {
		root html;
		index index.html;
	}
}
```

要想访问上述资源，很简单，只需要通过  http://192.168.200.133  直接就能访问，地址后面不需要加 /



````
server {
	listen	80;
	server_name localhost;
	location /frx {
		root html;
		index index.html;
	}
}
````



这个时候，要想访问上述资源，按照上述的访问方式，我们可以通过 http://192.168.200.133/frx/ 来访问，但是如果地址后面不加斜杠，如 http://192.168.200.133/frx，页面就会出问题。

如果不加斜杠，Nginx 服务器内部会自动做一个 301 的重定向，重定向的地址会有一个指令叫 `server_name_in_redirect` 来决定重定向的地址：

- 如果该指令为 on重定向的地址为：http://server_name/目录名/

- 如果该指令为 off重定向的地址为：http://原URL中的域名/目录名/


所以就拿刚才的地址来说，访问 http://192.168.200.133/frx 如果不加斜杠，那么按照上述规则：

- 如果指令 server_name_in_redirect 为 on，则 301 重定向地址变为 http://localhost/frx/，IP 发生改变，地址出现了问题
- 如果指令 server_name_in_redirect 为 off，则 301 重定向地址变为 http://192.168.200.133/frx/。这个符合我们的期望



注意 server_name_in_redirect 指令在 Nginx 的 0.8.48 版本之前默认都是 on，之后改成了 off，所以现在我们这个版本不需要考虑这个问题，但是如果是 0.8.48 以前的版本并且 server_name_in_redirect 设置为 on，我们如何通过 Rewrite 来解决这个问题？


```nginx

```

```nginx
location static/ {
	root /var/www/html;
}
```





### location指令

nginx官方文档给出location语法如下：

```nginx
location [=|~|~*|^~] uri {
	...
}
```





| 标识符 | 描述                                                         |
| ------ | ------------------------------------------------------------ |
| =      | **精确匹配**；用于标准uri前，要求请求字符串和uri严格匹配。如果匹配成功，就停止匹配，立即执行该location里面的请求。 |
| ~      | **正则匹配**；用于正则uri前，表示uri里面包含正则，并且区分大小写。 |
| ~*     | **正则匹配**；用于正则uri前，表示uri里面包含正则，不区分大小写。 |
| ^~     | **非正则匹配**；用于标准uri前，nginx服务器匹配到前缀最多的uri后就结束，该模式匹配成功后，不会使用正则匹配。 |
| 无     | **普通匹配（最长字符匹配）**；与location顺序无关，是按照匹配的长短来取匹配结果。若完全匹配，就停止匹配。 |



```nginx
location = / {  
   //精确匹配/ ，主机名后面不能带任何字符串
    echo "规则A";
}

location = /login {
  //精确匹配 /login 开头的地址，匹配符合以后，不在继续往下搜索 
    echo "规则B";
}

location ^~ /blog/ { 
  //非正则匹配，匹配/blog/后，停止往下搜索正则，采用这一条
  echo "规则C";
}
 
location ~  \.(gif|jpg|png|js|css)$ {
    //区分大小写的正则匹配  若匹配成功，停止往下搜索正则，采用这一条
    echo "规则D";
}

location ~* \.png$ {  
   //区分大小写的正则匹配 ，停止往下搜索正则，采用这一条
    echo "规则E";
}
 
location / {
  //因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求
  //如果没任何规则匹配上，就采用这条规则
    echo "规则F";
}
 
location /blog/detail { 
  //最长字符串匹配，若完全匹配成功，就不在继续匹配，否则还会进行正则匹配
  echo "规则G";
}
 
location /images {  
    //最长字符串匹配，同上 
    echo "规则Y";
}
 
location ^~ /static/files {  
    //非正则匹配，若匹配成功，就不在继续匹配
    echo "规则X";
```



- 当访问根路径/的时候，比如https://www.fengzhao.me/ ，会匹配规则A。

- 当访问http://www.fengzhao.me/login ，会匹配规则B。

- 当访问http://www.fengzhao.me/login.html ，会匹配规则F。

- 当访问http://www.fengzhao.me/blog/detail/3.html ，会匹配规则C。

分析思路，首先看看，“**精确匹配**”是否可以匹配成功，显示不可以；然后，看看是否可以“**普通匹配**”是否可以完全匹配，显示也没有；接着在看看非正则匹配，是否可以匹配成功，发现同规则C匹配上了，所以采用了规则C。





### internal 指令

在Nginx中，internal location是一种特殊的URL，它只能从Nginx内部访问，不能从客户端浏览器直接访问。

这种规则通常用于内部的微服务通信，并且可以减少对外部的负载以及提高安全性。



Nginx 的 [internal 指令](http://nginx.org/en/docs/http/ngx_http_core_module.html#internal)可以用来限制 Web 公共目录下的图片等资源文件被任意用户直接访问。

一个明显的使用场景是，对于用户上传的认证图片，属于个人隐私资源，不应该让所有用户都能访问得到，通常只能由管理员审核时查看。

假定需要限制访问的图片的 URL 路径是 /images/auth-pictures/，Nginx 进行如下配置：

```nginx
location ^~ /images/auth-pictures/ {
  internal;
}
```

重启 Nginx，直接访问 /images/auth-pictures/ 下的图片，会返回 404



```nginx
server {
  listen  80;
  server_name your.host;

  access_log off;

  location /api {
    proxy_pass http://localhost:3000;
  }

  location /internal {
    internal;
    proxy_pass http://localhost:3000;
  }
}
```





# Nginx模块

打开[官方文档](https://nginx.org/en/docs/)中，可以看到Nginx的语法和模块被分为`Introduction`,`How-To`,`Development`,`Modules reference` 四块。



Nginx 的模块系统主要分为“核心功能模块”和“动态模块”，其中动态模块又分为官方模块和三方模块。某种意义上来看，Nginx 的模块算是一种 AOP 思想的应用实践。





## 内部模块

Nginx 能保持高度曝光发展到今天，除了因为有大量三方模块外，这些拥有稳定质量的内部模块同样功不可没。时至今日，[这些模块](https://github.com/nginx/nginx/tree/master/src)还在保持着比较高的频率进行小步迭代，不断进行优化。它们实际如下：

- 负责内部通用数据类型、数据对象、内存管理、文件管理、哈希校验、网络通信、锁、网络连接、日志管理、计时器的“核心模块”；

- 负责在不同操作系统，使用不同的事件方案最优解的“事件模块”；
- 负责门面担当、提供高性能 Web 服务的 “HTTP 模块”；
- 提供通用 TCP 代理服务功能的“流模块”；
- 负责邮件服务代理功能的“邮件功能”；以及解决系统差异的“OS模块”。



这些模块是 Nginx 的一部分，在一次次编译后，伴随着二进制软件包被分发至千家万户，跨越国界、跨越操作系统，大到绵延数个国家的跨国商业公司、小到你家里的路由器、甚至是电梯里的工控机中都能看到它的身影。

如果 Nginx 缺少了以上任何一个模块、或者模块和 Nginx 主文件版本不一致，软件都将停止工作、或者无法提供高质量的服务能力，可以被称之“亲儿子模块”，都属于标准的静态模块。

随着 Nginx 版本迭代更新，如果这些模块没有跟上版本迭代而和 Nginx 一起重新构建编译，那么原本的功能便会失效或者引起软件故障。漫长的编译过程，对于模块维护者，尤其是为爱发电的开源作者们来说，无疑是一个不必要的负担。



## 外部模块









## 常见官方模块



### ngx_http_core_module

提供http协议的支持。平常配置的http段、server虚拟主机段、location段等。都是此模块的中的一些配置语法。

### ngx_http_gzip_module

使用`gzip`方法压缩，有助于将传输数据的大小减少为一半甚至更多。提供请求返回速度。



**什么是网站gzip压缩**

正常浏览器通过URI访问服务时，下载的资源都是源文件大小。开启gzip压缩时，服务器在响应之前，对资源进行gzip压缩，并追加Content-Encoding: gzip响应头。

浏览器接收响应之后，会检查Content-Encoding响应头，若是gzip，则先对响应进行gzip解压，然后交给浏览器，进行解析及渲染等一系列操作。



**网站gzip压缩的优点**

网站开启gzip以后，会将输出到用户浏览器的数据进行压缩处理，这样会减小通过网络传输的数据量，达到提升网页加载速度、提升用户浏览体验。

网站开启gzip并非全是优点，gzip压缩算法属于依赖CPU型操作，在服务器端大量的资源进行gzip压缩，会占用服务器CPU和磁盘资源。但对于目前CPU性能来说，其影响微乎其微。

使用SSL/TSL协议时，压缩的响应可能会受到BREACH攻击。



### ngx_http_proxy_module

该模块允许将请求转发到其他服务器，实现代理服务器的功能。常见于实现反向代理服务器。





### ngx_http_upstream_module 



### ngx_http_gzip_module



### ngx_http_map_module 

map 指令是由 `ngx_http_map_module` 模块提供的，默认情况下nginx 会安装该模块。

map 的主要作用是`创建自定义变量`，通过使用 nginx 的`内置变量`,去`匹配`某些特定规则;

```nginx
# $args 是nginx内置变量，就是获取的请求 url 的参数。

# map定义两个变量的映射关系：当 $args 的值等于 debug 的时候，$foo 变量的值就是 1，否则 $foo 的值就为 0.

map $args $foo {
    	default     0;
    	debug       1;
    }

server {
        listen 8080;

        location /test {
        	# 将变量$foo的值赋给变量$orig_foo
            set $orig_foo $foo;
        
        	# 强行修改 $args 的值为 debug
            set $args debug;

            echo "original foo: $orig_foo";
            echo "foo: $foo";
        }
    }
curl 'http://localhost:8080/test'

# 第一行输出"original foo: 0"
# 这个请求并没有提供 URL 参数串，$args 最初就是空值，根据map规则，$foo则应当为0

# 第二行输出"foo: 0"
# 在强行改写 $args 变量的值为字符串 debug 之后，$foo 仍然是 0，显然不符合map规则。

# 原因是$foo在第一次读取时，根据映射规则计算出的值被缓存住了



```



## 动态模块

原生 Nginx 增加、修改一个第三方模块，需要重新编译源代码，所有的模块都是用静态链接的形式组织起来的。

Tengine 有一个增强的功能，即动态模块加载 DSO(Dynamic Shared Objects)，可以实现运行时动态加载模块，而不用每次都要重新编译Tengine。

在 2016 年农历春节期间，Nginx 官方发布了最新版本 Nginx-1.9.11，也增加了该功能。

从使用的角度上来说，是增加了一个指令 [load_modules](http://nginx.org/en/docs/ngx_core_module.html#load_module) 指令，来加载编译好 so 形式的动态模块。







```
具体使用的时候,主要为6个步骤;

　　(1):首先,要在nginx的源代码中加入configure 加入动态模块的时候必须指明这个模块是使用动态模块的的方式编译进nginx中;这里有一个潜台词,不是所有的nginx模块都可以以动态模块的方式加入到nginx中;只有一些模块才可以以动态模块的方式加入;

　　(2):开始执行make,编译出binary;

　　(3):到第三步的时候,也就是说我们开始启动nginx了;启动nginx的时候尼我们去读ngx_module里的数组;

　　(4):读到模块数组中尼,我们发现了使用了一个动态模块,接下来我们会看到一个nginx的conf中加入的一个配置项,这个配置项叫load_module配置;指明了这个　　　  动态模块所在的路径,

　　(5):那么接下来我们就可以在nginx的进程中打开这个动态库加入模块数组,

　　(6):最后再进行一个初始化的过程(基于模块数组进程初始化);
```







NGINX 1.9.11开始增加加载动态模块支持，从此不再需要替换nginx文件即可增加第三方扩展。目前官方只有几个模块支持动态加载，第三方模块需要升级支持才可编译成模块。

https://www.cnblogs.com/binghe001/p/13303716.html





# 重写和重定向

一直对nginx的重写和重定向都是只有一个模糊的认识，只是知道在nginx里return、rewrite、proxy_pass能实现我想要的转发。

每次查阅资料时，各种关键词充斥在眼前：“重写”、“重定向”、“隐式转发”、“内部重定向”......一直没有区分清楚他们之前的区别或联系。



随之产生几个问题，想要花点时间搞清楚它们：

- 重写和重定向的区别是什么？
- nginx中“重写”、“重定向”、“隐式转发”、“内部重定向”......这些名词的关系是什么？在nginx是否都由一个独立的模块、关键字来实现这些的？
- nginx中`return`、`rewrite`、`proxy_pass`它们的区别是什么？对于重写和重定向，它们是否各自实现不同的功能？



首先重写和重定向的最终目的是一样的

假如你通过浏览器和固定的链接经常访问一张“好看的图片”，有一天图片的维护者将它移动了位置（换了目录、或者干脆移动到其他域名），那意味着你访问不到这张图片了？

为了避免这样的情况给用户带来的困扰，可以使用**重写**或者**重定向**，**将你的请求转向新的位置**（这张图片新的位置），对你来说还是用老的固定的链接访问到了你喜欢的图片。



**重定向**：重定向是用户请求服务端后，服务端向客户端返回HTTP 301、302（303、304、307、308）响应，告诉客户端需要去尝试另一个URL。

意味着客户端知道使用另一个URL并去访问。（客户端发起两次请求）

重定向的请求路径如下：

- request1（来自客户端）：访问“好看的图片”
- response1（来自服务端）：你要访问的图片不在这了，你需要去访问“好看的图片新的位置”
- request2（来自客户端）：访问“好看的图片新的位置”
- response2（来自服务端）：拿去吧，你要的“好看的图片新的位置”对应的图片



**重写**：重写发生在服务器上。服务器内部将一个URL转到另一个URL，然后返回给客户端。

客户端并不知道自己的请求被转过一次，浏览器中的URL也始终是一开始访问的那个。（客户端发起一次请求）

重写的请求路径如下：

- request1（来自客户端）：访问“好看的图片”
- 重写（服务端处理）：将“好看的图片”改到“好看的图片新的位置”，获取到图片

- response1（来自服务端）：拿去吧，你要的“好看的图片”对应的图片



从浏览器的反馈来看。重写-客户端只会发送一次请求；重定向-客户端会发送两次请求。

重写和重定向在上面已经解释过了。关于其他名词的解释，在网上搜罗了一下：

- 隐式转发/隐形转发/隐藏式跳转：将请求跳转到另一个网站的页面，并且浏览器中URL保持不变。
- 显示转发：将请求跳转到另一个网站的页面，浏览器中URL会发生改变。
- 内部重定向：内部重定向（重写）发生在server端内部，client端不知情，浏览器上URL不会改变。
- 外部重定向：外部重定向是server端通知client端需要访问新的URL，client端进行第二次访问。浏览器中URL也变成新的URL。

思来想去，似乎就是对重写和重定向取了好多名字。所以个人理解的总结：

重写     = 隐式转发 = 内部重定向
重定向 = 显示转发 = 外部重定向





# Nginx限流配置



流量限制(rate-limiting)，是 Nginx 中一个非常实用，却经常被错误理解和错误配置的功能。我们可以用来限制用户在给定时间内 HTTP 请求的数量。

请求，可以是一个简单网站首页的 GET 请求，也可以是登录表单的 POST 请求。



流量限制可以用作安全目的，比如可以减慢暴力密码破解的速率。

通过将传入请求的速率限制为真实用户的典型值，并标识目标URL地址(通过日志)，还可以用来抵御 DDOS 攻击。

更常见的情况，该功能被用来保护上游应用服务器不被同时太多用户请求所压垮。





- [ngx_http_limit_req_module](https://nginx.org/en/docs/http/ngx_http_limit_req_module.html)

- [ngx_http_limit_conn_module](https://nginx.org/en/docs/http/ngx_http_limit_conn_module.html)



ngx_http_limit_conn_module 对于一些服务器流量异常、负载过大，甚至是大流量的恶意攻击访问等，进行并发数的限制；

该模块可以根据定义的键来限制每个键值的连接数，只有那些正在被处理的请求（这些请求的头信息已被完全读入）所在的连接才会被计数。



该模块提供了两个配置参数，limit_conn_zone 和 limit_conn 。

其中 limit_conn_zone 只能配置在 http{} 段，而 limit_conn 则可以配置于http{}，server{}，location{} 区段中。



https://www.cnblogs.com/biglittleant/p/8979915.html





注意事项：



事务都具有两面性的。ngx_http_limit_conn_module 模块虽说可以解决当前面临的并发问题，但是会引入另外一些问题的。

如前端如果有做LVS或反代，而我们后端启用了该模块功能，那不是非常多503错误了？这样的话，可以在前端启用该模块，要么就是设置白名单。





# Nginx热升级

 热升级要升级的部分一般是要**添加新的模块**或者**升级Nginx版本**。前者如果是编译第三方模块需要先准备好模块源代码，对于后者需要先下载最近Nginx源码。

热升级是指在**不停止服务（不影响客户端访问）**的情况下更换 Nginx 的binary文件。

这种热升级得益于nginx的**多进程架构**设计，能够在老的nginx主进程不退出的情况下以子进程的方式启动新的master进程和新的woker进程，让新的master进程重新监听端口和接收请求。

新的master进程稳定之后，通过发送信号的方式通知老master进程退出。完成整个热升级。





热升级会经历以下几个步骤：

**第一步**是把旧的 Nginx binary 文件替换为新的，之所以说只替换 binary 文件是因为大部分场景下，我们新编译的 nginx 文件所指定的相应的配置选项，比如说配置文件的目录在哪里？log 的所在目录在哪里？

必须保持和老的 Nginx 是一致的，否则的话没有办法复用 nginx.conf 文件，如果我们仅仅替换 binary 文件，请注意要备份，另外在新版本的 Linux 中，会要求在覆盖一个正在使用的文件时需要用 cp -f 才能够替换。

```bash
# 第一步：先查看原先编译的参数。nginx -V可以查看编译时的参数（-v是查看版本）。在新编译时，要将原有的模块参数也加上，否则原有的模块不会编译进去。

# 第二步：开始编译，编译过程和前面的一致，只是增加了要添加模块的参数。
```



**第二步**向现有老的 Master (Old) 进程发生 USR2 信号，之后 Master (Old) 进程会将修改 pid 文件名，添加 后缀 .oldbin。这一步是在为新的 Master 进程让路，虽然 Master、Worker 进程都可以接受信号，但是为了管理方便，通常不对 Worker 进程直接发送信号，所以我们依赖于 Master 进程，他必须把他的 pid 保存下来，为了新的 Master 使用 pid.bin 这个文件名，所以把老的 pid 文件改为 pid.oldbin。



热升级大致分为两步，按照新的要求编译好Nginx的二进制文件，通过信号，完成新老进程的平滑过渡，保证升级期间服务可用。







第一步：先查看原先编译的参数。-V可以查看编译时的参数。（-v是查看版本）

在新编译时，要将原有的模块参数也加上，否则原有的模块不会编译进去。

```
./nginx -V
```



- 第二步：开始编译，编译过程和[上篇](https://blog.csdn.net/gexiaoyizhimei/article/details/101567219)一致，只是增加了要添加模块的参数。



https://blog.csdn.net/gexiaoyizhimei/article/details/101650717

https://www.cnblogs.com/wupeixuan/p/12074007.html

# Nginx 安全配置规范



## 禁止IP访问

 一台服务器部署多个网站的时候，为了确保用户访问特定的网站，就要求用户使用域名访问，不能使用IP；另外，也可以防止一些未备案的域名解析到服务器，导入服务器被断网。 







## 隐藏版本号





# Nginx 反向代理和负载均衡



四层和七层负载均衡

- 所谓四层就是基于IP+端口的负载均衡；七层就是基于URL等应用层信息的负载均衡；同理，还有基于MAC地址的二层负载均衡和基于IP地址的三层负载均衡。

- 二层负载均衡会通过一个虚拟MAC地址接收请求，然后再分配到真实的MAC地址；
- 三层负载均衡会通过一个虚拟IP地址接收请求，然后再分配到真实的IP地址；
- 四层通过虚拟IP+端口接收请求，然后再分配到真实的服务器；
- 七层通过虚拟的 URL 或 主机名 接收请求，然后再分配到真实的服务器。



我们最常见的 nginx location proxy_pass 反向代理，就是基于 URL 匹配将 HTTP 请求转到真实的后端服务。





### 在nginx内部处理3xx跳转



nginx反向代理，后端服务器可能返回 3XX 的redirect的response, Nginx会把这个请求直接返回给客户端。

现在我们的需求是让Nginx自己处理这个跳转，而客户端无感知。



### nginx负载均衡算法



#### **轮询 （round-robin）**

轮询为负载均衡中较为基础也较为简单的算法，它不需要配置额外参数。

假设配置文件中共有 $M$ 台服务器，该算法遍历服务器节点列表，并按节点次序每轮选择一台服务器处理请求。当所有节点均被调用过一次后，该算法将从第一个节点开始重新一轮遍历。

**特点**：由于该算法中每个请求按时间顺序逐一分配到不同的服务器处理，因此适用于服务器性能相近的集群情况，其中每个服务器承载相同的负载。但对于服务器性能不同的集群而言，该算法容易引发资源分配不合理等问题。



#### 加权轮询

```nginx
# 定义一个后端服务，由三个节点组成
upstream cluster  {
    server backend1-inc.example.com        weight=5;
    server backend2-inc.example.com:8080;
    server unix:/tmp/backend3;

    server backup1.example.com:8080   backup;
    server backup2.example.com:8080   backup;
}

server {
   location / {
   		proxy_set_header X-Real-IP $remote_addr;               //返回真实IP
   		proxy_pass http://cluster;                             //代理指向cluster 
    
}
}
```







**上游**

upstream 即上游的意思，是一个想对到概念，从客户端到中间的网络链路到服务器到链路中，可以将越接近客户到设备越理解成下游，相反到为上游。

所以如果只有一个upstream，可以将其为理解成转发客户到请求到服务器，然后响应服务器转发到客户端到过程。

**下游**





 `ngx_http_proxy_module` 模块可以使发到 nginx 的请求转发到真正的另外一个后端服务器上。





**反向代理时的头部处理**



在实际应用中，我们的后端服务器可能需要获取客户端用户的 ip 地址，比如做异地登陆的判断，或者统计 ip 访问次数等，通常情况下我们使用 request.getRemoteAddr() 就可以获取到客户端 ip。

但是当我们使用了 nginx 作为反向代理后，使用 request.getRemoteAddr() 获取到的就一直是 nginx 服务器的 ip 的地址。

经过反向代理后，由于在客户端和 web 服务器之间增加了中间层，因此 web 服务器无法直接拿到客户端的 ip，通过 $remote_addr 变量拿到的将是反向代理服务器的 ip 地址。



如果服务是直接暴露在公网上，根据TCP的原理通过socket是可以拿到真实的用户IP的。但是为了安全性和负载均衡的需要我们很少会直接把后端服务直接放在公网上，通常会在服务前置`Nginx`、`Haproxy`等反向代理软件，有时为了需要还会加多层代理，比如CDN和WAF等，这时如何能获取到用户的IP就成了问题，因为根据TCP的原理，反向代理时上一层和下一层代理建连，后层代理只能获取到上一层代理的IP，没法获取到用户的源IP。





`X-Forwarded-For`是 HTTP头的一个字段，最开始是由 `Squid`这个缓存代理软件引入，在客户端访问服务器的过程中如果需要经过HTTP代理或者负载均衡服务器，可以被用来获取最初发起请求的客户端的IP地址，如今它已经成为事实上的标准，被各大 HTTP 代理、负载均衡等转发服务广泛使用。 [RFC 7239](http://tools.ietf.org/html/rfc7239)（Forwarded HTTP Extension）是这个头信息的标准化版本。



X-Forwarded-For 格式：

```shell
X-Forwarded-For: <client>, <proxy1>, <proxy2>
```



- client：客户端的IP地址。
- proxy1, proxy2：如果一个请求经过了多个代理服务器，那么每一个代理服务器的IP地址都会被依次记录在内。也就是说，最右端的IP地址表示最近通过的代理服务器，而最左端的IP地址表示最初发起请求的客户端的IP地址。



**`X-Forwarded-For`只规定了这个字段的格式，并不代表这是代理服务器的默认行为，是否增加还要是具体配置。**



#### Nginx 处理 X-Forwarded-For

Nginx做反向代理时为了让后端服务能获取到真实的用户ip网上的教程大多会让增加下边两行配置：

```nginx
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
```

**$proxy_add_x_forwarded_for 变量的含义**

- 如果请求中不带X-Forwarded-For头，那么取`$remote_addr`的值；
- 如果请求中带X-Forwarded-For头，那么在X-Forwarded-For后追加`$remote_addr`，即: `X-Forwarded-For,$remote_addr`



因为`X-Forwarded-For`只是一个http的请求头，客户端很容易伪造一个 X-Forwarded-For 请求头。这时`Nginx`如果使用上边的配置的话由于`X-Forwarded-For`不为空，所以`Nginx`只会在现在值的基础上追加，这样后端服务在拿到头后根据约定取最左边ip话就会拿到一个伪造的IP，会有安全风险。

```shell
curl -H "X-Forwarded-For: 8.8.8.8" https://www.google.com 
```

由于请求头是不可靠的，我们不能信任客户端传过来头信息，那么如何解决呢？



TCP不像UDP必须经过3次握手，客户端的IP是无法伪造的，所以**最外层的代理**一定要取`$remote_addr`的值，对应配置：

```nginx
proxy_set_header X-Real-IP $remote_addr;
proxy_set_header X-Forwarded-For $remote_addr;
```







# 初探 nginx 架构

nginx 在启动后，在 unix 系统中会以 daemon 的方式在后台运行，后台进程包含一个 master 进程和多个 worker 进程。

我们也可以手动地关掉后台模式，让 nginx 在前台运行，并且通过配置让 nginx 取消 master 进程，从而可以使 nginx 以单进程方式运行。

很显然，生产环境下我们肯定不会这么做，所以关闭后台模式，一般是用来调试用的，在后面的章节里面，我们会详细地讲解如何调试nginx。

**nginx是以多进程的方式来工作的，当然nginx也是支持多线程的方式的，只是我们主流的方式还是多进程的方式，也是nginx的默认方式。**



**为什么 Nginx 不使用多线程？**

Apache: 创建多个进程或线程，而每个进程或线程都会为其分配 cpu 和内存（线程要比进程小的多，所以worker支持比perfork高的并发），并发过大会耗光服务器资源。

Nginx: 采用单线程来异步非阻塞处理请求（管理员可以配置Nginx主进程的工作进程的数量）(epoll)，不会为每个请求分配cpu和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。



Nginx 最核心的一个目的是要保持高可用性、高可靠性，而当 Nginx 如果使用的是多线程结构的时候，因为线程之间是共享同一个地址空间的，所以当某一个第三方模块引发了一个地址空间导致的段错误时、在地址越界出现时，会导致整个 Nginx 进程全部挂掉。而当采用多进程模型时，往往不会出现这样的问题。从上图可以看到 Nginx 在做进程设计时，同样遵循了实现高可用、高可靠这样的一个目的。





## Nginx进程模型



多进程中的 Nginx 进程架构如下图所示：



![Nginx进程结构](./assets/nginx-models.png)



nginx在启动后，会有一个`master`进程和多个`worker`进程。

- master进程主要用来管理worker进程，作用包括：
  - 接收来自外界的信号，向各worker进程发送信号。比如 reload 重载配置文件，重启nginx等。
  - 监控worker进程的运行状态，当worker进程退出后(异常情况下)，会自动重新启动新的worker进程。

- worker进程：
  - worker才是真正的工作进程，处理网络请求事件。各进程互相之间是独立的。
  - 一个请求，只可能在一个worker进程中处理。
  - Nginx 中还有两个特殊用途的进程：**缓存加载器进程（Cache Loader ）**和 **缓存管理器进程（Cache Manager）**
  - `cache loader`进程负责检测磁盘的缓存，且向内存数据库提供缓存元数据，`cache loader`在Nginx准备启动时，以一定的目录结构，遍历缓存内容的元数据，更新共享内存中的相关条目，**当准备完成后退出**。
  - `cache manager`进程主要负责缓存的过期管理和诊断。**一般存在于主进程的整个生命周期**，负责对缓存索引进行管理。通过缓存机制，可以提高对请求的响应效率，进一步降低网络压力。







master来管理worker进程，所以我们只需要与master进程通信就行了。master进程会接收来自外界发来的信号，再根据信号做不同的事情。

所以我们要控制nginx，只需要通过kill向master进程发送信号就行了。比如kill -HUP pid，则是告诉nginx，从容地重启nginx，我们一般用这个信号来重启nginx，或重新加载配置，因为是从容地重启，因此服务是不中断的。

master进程在接收到HUP信号后是怎么做的呢？首先master进程在接到信号后，会先重新加载配置文件，然后再启动新的worker进程，并向所有老的worker进程发送信号，告诉他们可以光荣退休了。

新的worker在启动后，就开始接收新的请求，而老的worker在收到来自master的信号后，就不再接收新的请求，并且在当前进程中的所有未处理完的请求处理完成后，再退出。

当然，直接给master进程发送信号，这是比较老的操作方式，nginx在0.8版本之后，引入了一系列命令行参数，来方便我们管理。比如，./nginx -s reload，就是来重启nginx，./nginx -s stop，就是来停止nginx的运行。

如何做到的呢？

执行 nginx -s reload 命令时，其实是启动一个新的nginx进程，而新的nginx进程在解析到reload参数后，就知道我们的目的是控制nginx来重新加载配置文件了，它会向master进程发送信号，然后接下来的动作，就和我们直接向master进程发送信号一样了。



**work进程**

Nginx并不会为每一个连接新建一个进程来进行处理，相反，`worker`会从一个共享的监听套接字中获取新的请求，并在`worker`管理的Run-loop中处理请求。

Nginx启动时，将创建初始的监听套接字，接下来，当`worker`处理`HTTP`请求和响应时，会持续的接收、读取、以及写入套接字。

Run-loop是`worker`的核心，它的主要思想是异步任务处理，实现方式包括模块化、事件通知、回调函数、定时器等。总的原则就是尽可能的非阻塞。

关于`worker`的数量问题，通常的建议是：

- CPU密集型：比如处理大量的TCP/IP，SSL，或压缩时，Nginx `worker`进程的数量应当和CPU核的数量一致。
- 磁盘I/O密集型：提供文件内容，或者大量的代理，这种情况下，`worker`进程的数量可以是CPU核数的1.5或2倍。



每个 Worker 进程都是从 Master 进程fork过来，在 Master 进程里面，先建立好需要 listen 的 socket（listenfd）之后，然后再 fork 出多个 Worker 进程。

所有 Worker 进程的 listenfd 会在新连接到来时变得可读，为保证只有一个进程处理该连接，所有 Worker 进程在注册 listenfd 读事件前抢互斥锁accept_mutex，抢到互斥锁的那个进程注册 listenfd 读事件，在读事件里调用 accept 接受该连接。

当一个 Worker 进程在 accept 这个连接之后，就开始读取、解析、处理请求，在产生数据后再返回给客户端，最后才断开连接，这样一个完整的请求就是这样的了。

我们可以看到，一个请求完全由 Worker 进程来处理，而且只在一个 Worker 进程中处理。



Nginx 采用这种进程模型有什么好处呢？首先，对于每个 Worker 进程来说，独立的进程不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。

其次，采用独立的进程可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断， Master 进程则很快启动新的 Worker 进程。

当然， Worker 进程异常退出，肯定是程序出现了bug，异常退出会导致当前 Worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。好处还有很多，大家可以慢慢体会。





**异步非阻塞**



一个请求的完整过程。首先，请求过来，要建立连接，然后再接收数据，接收数据后，再发送数据。

具体到系统底层，就是读写事件，而当读写事件没有准备好时，必然不可操作，如果不用非阻塞的方式来调用，那就得阻塞调用了，事件没有准备好，那就只能等了，等事件准备好了，你再继续吧





# Nginx基础概念

















# nginx 第三方模块







## 访问控制



### GEOIP访问控制

对于在公网部署的应用，需要通过检测访问者的 IP ，来决定转发策略，或者是否访问。可以采用  ngx_http_geoip2_module 模块。

GeoIP2 是 MaxMind 公司推出的知名 IP 定位数据库，数据库每周更新。可以通过 [github](https://github.com/fengzhao-study-notes/maxmind-geoip/releases) 下载。



利用访问

nginx的版本比较重要，低于`1.9.11`版本的nginx无法使用动态模块，低于`1.11.5`版本的nginx编译动态模块时不支持`--with-compat`兼容参数，所以请保证您的nginx版本不低于`1.11.5`。



ngx_http_geoip2_module 





```shell
# 如果nginx是编译安装的，可以用nginx -V查看nginx源版本和编译参数

[root@stxz-elk-01 nginx-1.21.4]#
[root@stxz-elk-01 nginx-1.21.4]# /usr/local/nginx/sbin/nginx  -V
nginx version: nginx/1.21.4
built by gcc 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC)
built with OpenSSL 1.0.2k-fips  26 Jan 2017
TLS SNI support enabled
configure arguments: --user=nginx --group=nginx --prefix=/usr/local/nginx/ --with-http_stub_status_module --with-http_ssl_module
[root@stxz-elk-01 nginx-1.21.4]#


# 下载对应版本的nginx源代码，然后


 ./configure                                     \
 --user=nginx --group=nginx                      \
 --prefix=/usr/local/nginx/                      \
 --with-http_stub_status_module                  \
 --with-http_ssl_module                          \
 --add-dynamic-module=./ngx_http_geoip2_module   \
 --with-stream                                   \
 --with-compat






wget -O /usr/local/nginx/geo/GeoLiteCountry.mmdb  https://github.com/fengzhao-study-notes/maxmind-geoip/releases/download/20220301/Country.mmdb


wget -O /usr/local/nginx/geo/GeoLiteCity.mmdb https://github.com/fengzhao-study-notes/maxmind-geoip/releases/download/20220301/City.mmdb


wget -O /usr/local/nginx/geo/GeoLiteASN.mmdb https://github.com/fengzhao-study-notes/maxmind-geoip/releases/download/20220301/ASN.mmdb



```





# nginx事件驱动模型



事件驱动模型是Nginx服务器保障完整功能和具有良好性能的重要机制之一。









### 惊群效应

当你往一群鸽子中间扔一块食物，虽然最终只有一个鸽子抢到食物，但所有鸽子都会被惊动来争夺，没有抢到食物的鸽子只好回去继续睡觉， 等待下一块食物到来。

**这样，每扔一块食物，都会惊动所有的鸽子，即为惊群。**

简单地说：就是扔一块食物，所有鸽子来抢，但最终只一个鸽子抢到了食物。

**语义分析：食物只有一块，最终只有一个鸽子抢到，但是惊动了所有鸽子，每个鸽子都跑过来，消耗了每个鸽子的能量。**

**（这个很符合达尔文的进化论，物种之间的竞争，适者生存。）**

在多进程/多线程等待同一资源时，也会出现惊群。即当某一资源可用时，多个进程/线程会惊醒，竞争资源。这就是操作系统中的惊群。





"惊群"简单地来讲，就是多个进程(线程)阻塞睡眠在某个系统调用上，在等待某个 fd(socket)的事件的到来。

当这个 fd(socket)的事件发生的时候，这些睡眠的进程(线程)就会被同时唤醒，多个进程(线程)从阻塞的系统调用上返回，这就是"惊群"现象。

**"惊群"被人诟病的是效率低下，大量的 CPU 时间浪费在被唤醒发现无事可做，然后又继续睡眠的反复切换上。**





# Nginx变量漫谈



Nginx 的配置文件使用的就是一门微型的编程语言，许多真实世界里的 Nginx 配置文件其实就是一个一个的小程序。

它在设计上受 Perl 和 Bourne Shell 这两种语言的影响很大。



熟悉 Perl、Bourne Shell、C/C++ 等命令式编程语言的朋友肯定知道，**变量说白了就是存放“值”的容器。**

而所谓“值”，在许多编程语言里，既可以是 `3.14` 这样的数值，也可以是 `hello world` 这样的字符串，甚至可以是像数组、哈希表这样的复杂数据结构。

**然而在 Nginx 配置中，变量只能存放一种类型的值，因为也只存在一种类型的值，那就是字符串。**



比如我们的 `nginx.conf` 文件中有下面这一行配置：

```nginx
# 使用标准ngx_rewrite模块中的set配置指令对变量 $a 进行了赋值操作。
set $a "hello world";
```



Nginx 变量名前面有一个 `$` 符号，这是记法上的要求。**所有的 Nginx 变量在 Nginx 配置文件中引用时都须带上 `$` 前缀。**

这种表示方法和 Perl、PHP 这些语言是相似的。



虽然 `$` 这样的变量前缀修饰会让正统的 `Java` 和 `C#` 程序员不舒服，但这种表示方法的好处也是显而易见的，那就是可以直接把变量嵌入到字符串常量中以构造出新的字符串：

```nginx
# 声明一个变量a,并赋值为"hello"
set $a hello;

# 用变量a的值来声明变量b
set $b "$a, $a";

# 当前 $foo 变量的值保存在另一个用户变量 $orig_foo 中
set $orig_foo $foo;
```

这里我们通过已有的 Nginx 变量 `$a` 的值，来构造变量 `$b` 的值。

于是这两条指令顺序执行完之后，`$a` 的值是 `hello`，而 `$b` 的值则是 `hello, hello`

**这种技术在 Perl 世界里被称为“变量插值”（variable interpolation），它让专门的字符串拼接运算符变得不再那么必要。**

看一个比较完备的 nginx 配置文件示例：

```nginx
 server {
        listen 8080;

        location /test {
            set $foo hello;
        	// 使用echo配置指令将 $foo 变量的值作为当前请求的响应体输出
            echo "foo: $foo";
        }
    }


```

[nginx echo 模块](https://github.com/openresty/echo-nginx-module#readme)（这是一个第三方的nginx模块，如果是nginx，需要重新 [编译安装](https://blog.csdn.net/jeikerxiao/article/details/106763068)，不过在 openresty 已经编译进去了） 

```shell
# 使用curl访问这个地址，响应体返回nginx配置文件中声明的变量值
curl 'http://localhost:8080/test'
foo: hello
```



我们看到， [echo](http://wiki.nginx.org/HttpEchoModule#echo) 配置指令的参数也支持“变量插值”。不过，需要说明的是，并非所有的配置指令都支持“变量插值”。

事实上，指令参数是否允许”变量插值”，取决于该指令的实现模块。





## Nginx 变量的规则



- **Nginx 变量的创建和赋值操作发生在全然不同的时间阶段：**
  - **Nginx 变量的创建只能发生在 Nginx 配置加载的时候，或者说 Nginx 启动的时候；(Nginx启动的时候就会读取配置文件并加载)**
  - **Nginx 变量赋值操作则只会发生在请求实际处理的时候。**
  - 这意味着不创建而直接使用变量会导致启动失败，同时也意味着我们无法在请求处理时动态地创建新的 Nginx 变量。

- **Nginx 变量一旦创建，其变量名的可见范围就是整个 Nginx 配置，甚至可以跨越不同虚拟主机的 `server` 配置块。**

- **Nginx 变量名的可见范围虽然是整个配置，但每个请求都有所有变量的独立副本，或者说都有各变量用来存放值的容器的独立副本，彼此互不干扰。**

```nginx
   server {
        listen 8080;
        include mime.types;
		default_type text/html; 
		
        location /foo {
            echo "foo = [$foo]";
        }

        location /bar {
            set $foo 32;
            echo "foo = [$foo]";
        }
    }
```

这里我们在 `location /bar` 中用 `set` 指令创建了变量 `$foo`，于是在整个配置文件中这个变量都是可见的。

因此我们可以在 `location /foo` 中直接引用这个变量而不用担心 Nginx 会报错。



```shell
# 由于 set 指令因为是在 location /bar 中使用的，所以赋值操作只会在访问 /bar 的请求中执行。
$ curl 'http://localhost:8080/foo'
    foo = []
    
# 这个URL匹配到 location /bar，所以成功使用set赋值
$ curl 'http://localhost:8080/bar'
    foo = [32]
    
# 即使前面请求了这两个URL，再次请求/foo。依然是空的。因为各个请求都有自己独立的 $foo 变量的副本。
$ curl 'http://localhost:8080/foo'
    foo = []
```



**对于 Nginx 新手来说，最常见的错误之一，就是将 Nginx 变量理解成某种在请求之间全局共享的东西，或者说“全局变量”。**

**而事实上，Nginx 变量的生命期是不可能跨越请求边界的。**



### location 内部跳转



**关于 Nginx 变量的另一个常见误区是认为 "变量容器的生命期，是与 `location` 配置块绑定的"。其实不然。**我们来看一个涉及“内部跳转”的例子：

```nginx
   server {
        listen 8080;
		include mime.types;
		default_type text/html;
        location /foo {
        
            set $a hello;
        	# 如果直接请求/foo，则发生内部跳转，跳转到下面那个location
            echo_exec /bar;
        }

        location /bar {
            echo "a = [$a]";
        }
    }

```



这里我们在 `location /foo` 中，使用第三方模块 [ngx_echo](http://wiki.nginx.org/HttpEchoModule) 提供的 [echo_exec](http://wiki.nginx.org/HttpEchoModule#echo_exec) 配置指令，发起到 `location /bar` 的“内部跳转”。

**所谓“内部跳转”，就是在处理请求的过程中，在服务器内部，从一个 `location` 跳转到另一个 `location` 的过程。**

**这不同于利用 HTTP 状态码 `301` 和 `302` 所进行的“外部跳转”。**

**因为后者是由 HTTP 客户端配合进行跳转的，而且在客户端，用户可以通过浏览器地址栏这样的界面，看到请求的 URL 地址发生了变化。**

内部跳转和 `Bourne Shell`（或 `Bash`）中的 `exec` 命令很像，都是“有去无回”。另一个相近的例子是 `C` 语言中的 `goto` 语句。



对于上面的例子，如果请求的是 `/foo` 这个接口，那么整个工作流程是这样的：

- 先在 `location /foo` 中通过 [set](http://wiki.nginx.org/HttpRewriteModule#set) 指令将 `$a` 变量的值赋为字符串 `hello`
- 后通过 [echo_exec](http://wiki.nginx.org/HttpEchoModule#echo_exec) 指令发起内部跳转，又进入到 `location /bar` 中，再输出 `$a` 变量的值。因为 `$a` 还是原来的 `$a`(hello)。

如果客户端直接请求 `/bar` 接口，就会得到空的 `$a` 变量的值，因为它依赖于 `location /foo` 来对 `$a` 进行初始化。





**一个请求在其处理过程中，即使经历多个不同的 `location` 配置块，它使用的还是同一套 Nginx 变量的副本。**

值得一提的是，标准 [ngx_rewrite](http://wiki.nginx.org/HttpRewriteModule) 模块的 [rewrite](http://wiki.nginx.org/HttpRewriteModule#rewrite) 配置指令其实也可以发起“内部跳转”，例如上面那个例子用 [rewrite](http://wiki.nginx.org/HttpRewriteModule#rewrite) 配置指令可以改写成下面这样的形式

```nginx
 server {
        listen 8080;
		include mime.types;
		default_type text/html;
        location /foo {
            set $a hello;
            rewrite ^ /bar;
        }

        location /bar {
            echo "a = [$a]";
        }
    }
```

从上面这个例子我们看到，Nginx 变量值容器的生命期是与当前正在处理的请求绑定的，而与 `location` 无关。



前面我们接触到的都是通过 [set](http://wiki.nginx.org/HttpRewriteModule#set) 指令隐式创建的 Nginx 变量。这些变量我们一般称为“用户自定义变量”，或者更简单一些，“用户变量”。

既然有“用户自定义变量”，自然也就有由 Nginx 核心和各个 Nginx 模块提供的“预定义变量”，或者说“内建变量”（builtin variables）。



### nginx 内置变量

所有的 nginx 内置变量都可以在[官方文档](http://nginx.org/en/docs/varindex.html)中找到。Nginx 内建变量最常见的用途就是获取关于请求或响应的各种信息。

例如由 [ngx_http_core](http://nginx.org/en/docs/http/ngx_http_core_module.html) 模块提供的内建变量：

- [$uri](http://wiki.nginx.org/HttpCoreModule#.24uri)，可以用来获取当前请求的 URI（经过解码，并且不含请求参数）。
- [$request_uri](http://wiki.nginx.org/HttpCoreModule#.24request_uri) 则用来获取请求最原始的 URI （未经解码，并且包含请求参数）。

比如：

```shell
  location /test {
        echo "uri = $uri";
        echo "request_uri = $request_uri";
    }
```

在这个例子中，把 [$uri](http://wiki.nginx.org/HttpCoreModule#.24uri) 和 [$request_uri](http://wiki.nginx.org/HttpCoreModule#.24request_uri) 的值输出到响应体中。

```shell
 $ curl 'http://localhost:8080/test'
    uri = /test
    request_uri = /test

$ curl 'http://localhost:8080/test?a=3&b=4'
    uri = /test
    request_uri = /test?a=3&b=4

$ curl 'http://localhost:8080/test/hello%20world?a=3&b=4'
    uri = /test/hello world
    request_uri = /test/hello%20world?a=3&b=4
```



另一个特别常用的内建变量其实并不是单独一个变量，而是有无限多变种的一群变量，即名字以 `arg_` 开头的所有变量。

**一个例子是 `$arg_name`，这个变量的值是当前请求名为 `name` 的 URI 参数的值，而且还是未解码的原始形式的值。**

```nginx
location /test {
        echo "name: $arg_name";
        echo "class: $arg_class";
    }
```

在命令行上使用各种参数组合去请求这个 `/test` 接口：

```shell
$ curl 'http://localhost:8080/test'
    name: 
    class: 

$ curl 'http://localhost:8080/test?name=Tom&class=3'
    name: Tom
    class: 3

$ curl 'http://localhost:8080/test?name=hello%20world&class=9'
    name: hello%20world
    class: 9
```

其实 `$arg_name` 不仅可以匹配 `name` 参数，也可以匹配 `NAME` 参数，抑或是 `Name`，等等：

> **Nginx 会在匹配参数名之前，自动把原始请求中的参数名调整为全部小写的形式。**

```shell
$ curl 'http://localhost:8080/test?NAME=Marry'
    name: Marry
    class: 

$ curl 'http://localhost:8080/test?Name=Jimmy'
    name: Jimmy
    class: 
```

如果你想对 URI 参数值中的 `%XX` 这样的编码序列进行解码，可以使用第三方 [ngx_set_misc](http://wiki.nginx.org/HttpSetMiscModule) 模块提供的 [set_unescape_uri](http://wiki.nginx.org/HttpSetMiscModule#set_unescape_uri) 配置指令：

```nginx
 location /test {
        set_unescape_uri $name $arg_name;
        set_unescape_uri $class $arg_class;

        echo "name: $name";
        echo "class: $class";
    }
```



现在我们再看一下效果：

```shell
$ curl 'http://localhost:8080/test?name=hello%20world&class=9'
    name: hello world
    class: 9
# 空格果然被解码出来
```

从这个例⼦我们同时可以看到，这个 set_unescape_uri 指令也像 set 指令那样，拥有⾃动创建 Nginx 变量的功能。

需要指出的是，许多内建变量都是只读的，比如我们刚才介绍的 [$uri](http://wiki.nginx.org/HttpCoreModule#.24uri) 和 [$request_uri](http://wiki.nginx.org/HttpCoreModule#.24request_uri). 对只读变量进行赋值是应当绝对避免的，因为会有意想不到的后果，比如：

```nginx
location /bad {
	set $uri /blah;
  	echo $uri;
  }
```

这个有问题的配置会让 Nginx 在启动的时候报出一条令人匪夷所思的错误：

```
[emerg] the duplicate "uri" variable in ...

```











# Nginx 配置指令的执行顺序



大多数 Nginx 新手都会频繁遇到这样一个困惑，那就是当同一个 `location` 配置块使用了多个 Nginx 模块的配置指令时，这些指令的执行顺序很可能会跟它们的书写顺序大相径庭。

于是许多人选择了“试错法”，然后他们的配置文件就时常被改得一片狼藉。这个系列的教程就旨在帮助读者逐步地理解这些配置指令背后的执行时间和先后顺序的奥秘。



```shell
location /test {
   set $a 32;
   echo $a;
   set $a 56;
   echo $a;
}
```



从这个例子的本意来看，我们期望的输出是一行 `32` 和一行 `56`，因为我们第一次用 [echo](http://wiki.nginx.org/HttpEchoModule#echo) 配置指令输出了 `$a` 变量的值以后，又紧接着使用 [set](http://wiki.nginx.org/HttpRewriteModule#set) 配置指令修改了 `$a`. 

事实并非如此：

```
    $ curl 'http://localhost:8080/test'
    56
    56
```













# API限速



>  **面试题：给定一个公共API，限制每个用户每秒只能调用1000次，如何实现？这一个经典的API限速问题(API rate limiting)。**

在高并发的分布式系统，如大型电商系统中，由于接口 API 无法控制上游调用方的行为，因此当瞬间请求量突增时，会导致服务器占用过多资源，发生响应速度降低、超时乃至宕机，甚至引发雪崩造成整个系统不可用。

面对这种情况，一方面我们会提升 API 的吞吐量和 QPS（Query Per Second 每秒查询量），但总归会有上限。

另一方面为了应对巨大流量的瞬间提交，我们需要做对应的限流处理，也就是对请求量进行限制，对于超出限制部分的请求作出快速拒绝、快速失败、丢弃处理，以保证本服务以及下游资源系统的稳定。

**在应对秒杀，抢购等高并发压力的场景时，限流已经成为了标配技术解决方案**，为保证系统的平稳运行起到了关键性的作用。不管应用场景是哪种，**限流无非就是针对超过预期的流量，通过预先设定的限流规则选择性的对某些请求进行限流“熔断”**。

通过限流，我们可以很好地控制系统的**QPS**，从而达到保护系统的目的。接下来的内容将会介绍一下常用的限流算法以及他们各自的特点：



## **限流概述**

在业务安全性方面，我们常常会用到接口限流，主要是为了防止系统压力过大、保证每个用户请求的资源保持均匀以及屏蔽恶意请求。

在开发高并发系统时，有三把利器用来保护系统：缓存、降级和限流。那么何为限流呢？顾名思义，限流就是限制流量，就像你宽带包了1个G的流量，用完了就没了。

通过限流，我们可以很好地控制系统的qps，从而达到保护系统的目的。

- 缓存：缓存的目的是提升系统访问速度和增大系统处理容量
- 降级：降级是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行
- 限流：限流的目的是通过对并发访问/请求进行限速，或者对一个时间窗口内的请求进行限速来保护系统，一旦达到限制速率则可以拒绝服务、排队或等待、降级等处理

我们经常在调别人的接口的时候会发现有限制，比如微信公众平台接口、百度API Store、聚合API等等这样的，对方会限制每天最多调多少次或者每分钟最多调多少次。

比如，[腾讯云的API接口](https://cloud.tencent.com/document/api/213/15707) 就是对请求限流为 20 次/秒

几个常见的场景如下：

- 恶意注册
- 爬虫的过度抓取
- 秒杀场景

目前实现API接口限流的方式有几种常见的，简单来说原理很简单，无非是在一个固定的时间段内，限制API的请求速率，一般来说是根据IP，如果是登录用户的话，还可以用用户的ID。



**限制了后怎么做**

对于恶意请求，假如对方的反反爬虫做的一般的话，完全可以直接将对方的IP加入黑名单，但如果对方用的IP代理，那就不是限流这个方案能解决的了，需要更高级的反爬虫方案。

但是我想提一点，对方既然爬了你的数据，肯定有对方的用处，假如对方没有恶意，请求频率也没有让你的机器有太多压力，那也就算了，毕竟你可能也在爬其它人的数据，大家都是搞技术的，没准对方背着万恶的KPI呢。

但是，如果对方恶意爬取，那么你完全可以在探测到对方的请求之后，返回空数据，甚至以假乱真的数据欺骗对方，让对方无利可图，对方也可能就会主动放弃了。



**如何设计API的限流**

可用性和可靠性对于所有 Web 应用程序和 API 服务至关重要。如果您提供 API 服务，您可能体会过流量突增对服务质量的影响，甚至可能造成服务中断。

限制流量可以使 API 服务在下面的场景中更可靠：

- 某个用户直接或间接造成了流量飙升，我们需要确保对其他用户服务可用。

- 某个用户向 API 服务发送大量请求。 或者更糟的是，某个用户试图恶意冲垮服务器。

- 用户发送了大量低优先级请求，但我们希望确保不会影响其他高优先级请求。 例如，发送大量分析数据请求的用户可能会影响其他用户的关键事务。

- 系统内部产生错误，导致无法处理所有请求，不得不丢弃低优先级的请求。



**常见的限流算法和策略**

**计数器算法**

计数器算法是限流算法里最简单也是最容易实现的一种算法。

比如我们规定，对于A接口来说，我们1分钟的访问次数不能超过100个。（指所有并发用户一起）

那么我们可以这么做：在一开始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter。

- 将时间划分为固定的窗口大小，例如1s

- 在窗口时间段内，每来一个请求，对计数器加1。

- 当计数器达到设定限制后，该窗口时间内的之后的请求都被丢弃处理。

- 该窗口时间结束后，计数器清零，从新开始计数。如上图所示，10s内限制1000个请求，在第11s的时候计数器会从0重新开始计数。

  

**优点**：实现简单，并且内存占用小，我们只需要存储时间窗口中的计数即可；计数器限流方式比较粗暴，一次访问就增加一次计数，在系统内设置每 N 秒的访问量，超过访问量的访问直接丢弃，从而实现限流访问。 

**缺点**：流量曲线可能不够平滑，有“突刺现象” ”和 临界问题“ 。

- 突刺现象：如果在单位时间1s内允许100个请求，在10ms已经通过了100个请求，那后面的990ms，只能眼巴巴的把请求拒绝，我们把这种现象称为"突刺现象"。

- 临界问题：假设我们限流规则为每秒钟不超过 100 次接口请求，第一个 1s 时间窗口内，100 次接口请求都集中在最后的 10ms 内，在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内，虽然两个时间窗口内流量都符合限流要求，但是在这两个时间窗口临界的 20ms 内会集中有 200 次接口请求。如果不做限流，集中在这 20ms 内的 200 次请求就有可能压垮系统。





**滑动窗口算法**

滑动窗口算法是计数器算法的一种改进，将原来的一个时间窗口划分成多个时间窗口，并且不断向右滑动该窗口。

流量经过滑动时间窗口算法整形之后，可以保证任意时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑，可以部分解决上面提到的临界突发流量问题。

对比固定时间窗口限流算法，滑动时间窗口限流算法的时间窗口是持续滑动的，并且除了需要一个计数器来记录时间窗口内接口请求次数之外，还需要记录在时间窗口内每个接口请求到达的时间点，对内存的占用会比较多。

滑动窗口计数法的思路是：

1. 将时间划分为细粒度的区间，每个区间维持一个计数器，每进入一个请求则将计数器加一；
2. 多个区间组成一个时间窗口，每流逝一个区间时间后，则抛弃最老的一个区间，纳入新区间。如图中示例的窗口 T1 变为窗口 T2；
3. 若当前窗口的区间计数器总和超过设定的限制数量，则本窗口内的后续请求都被丢弃。

